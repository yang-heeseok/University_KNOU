# 3강. 파이썬 기초 (보충)   

## 학습 목표
1. 파이썬의 기본 자료형(정수, 실수, 문자열, 불리언)을 이해하고 `type()` 함수로 확인할 수 있다.
2. 리스트(List)와 딕셔너리(Dictionary)의 차이를 설명하고, 데이터를 저장하고 조회할 수 있다.
3. 리스트의 인덱싱(indexing)과 슬라이싱(slicing)을 사용하여 원하는 원소에 접근할 수 있다.
4. 조건문(`if`)과 반복문(`for`)의 기본 구조를 이해하고, 들여쓰기의 중요성을 설명할 수 있다.
5. 함수(`def`)를 정의하고 호출하여 코드의 재사용성을 높일 수 있다.

---

## 📝 요약 (Summary)
1.  **자료형 (Data Types)**: 데이터의 종류를 나타내는 것으로, `type()` 함수를 통해 정수(`int`), 실수(`float`), 문자열(`str`) 등을 확인할 수 있습니다.
2.  **변수 (Variables)**: 데이터를 저장하는 메모리 공간에 붙이는 이름입니다. 변수를 사용하여 연산하거나 다른 값을 재할당할 수 있습니다.
3.  **리스트 (List)**: 여러 데이터를 순서대로 저장하는 자료구조입니다. 0부터 시작하는 인덱스(`a[0]`)로 각 원소에 접근하며, 슬라이싱(`a[1:3]`)을 통해 부분 리스트를 추출할 수 있습니다.
4.  **딕셔너리 (Dictionary)**: '키(Key)'와 '값(Value)'을 한 쌍으로 묶어 저장하는 자료구조입니다. 순서가 없는 대신, 고유한 키를 통해 값을 빠르게 조회, 추가, 삭제할 수 있습니다.
5.  **불리언 (Boolean)**: `True`(참)와 `False`(거짓) 두 가지 값만 가지는 자료형으로, `and`, `or`, `not` 논리 연산자와 함께 조건문에서 핵심적인 역할을 합니다.
6.  **제어문 (Control Flow)**: 코드의 실행 흐름을 제어하는 구문입니다. 조건에 따라 다른 코드를 실행하는 `if`문과 특정 코드를 반복 실행하는 `for`문이 대표적입니다. 파이썬에서는 들여쓰기(indentation)를 통해 코드 블록을 구분하므로 매우 중요합니다.

---

## ✏️ 심화 학습 (Study Subject)

### 1. 파이썬 자료구조 심층 비교: 리스트, 튜플, 딕셔너리, 세트

파이썬은 데이터를 효율적으로 관리하기 위한 다양한 내장 자료구조를 제공합니다. 각 자료구조의 특징을 이해하고 상황에 맞게 사용하는 것이 중요합니다.

#### 가. 관점별 비교

| 구분 | 리스트 (List) | 튜플 (Tuple) | 딕셔너리 (Dictionary) | 세트 (Set) |
| :--- | :--- | :--- | :--- | :--- |
| **형태** | `[1, 2, 3]` | `(1, 2, 3)` | `{'key': 'value'}` | `{1, 2, 3}` |
| **순서 (Ordering)** | **있음 (Ordered)** | **있음 (Ordered)** | 순서 없음 (Python 3.7+ 부터는 입력 순서 유지) | **없음 (Unordered)** |
| **변경 가능성 (Mutability)** | **가능 (Mutable)** | **불가능 (Immutable)** | **가능 (Mutable)** | **가능 (Mutable)** |
| **중복 (Duplicates)** | 허용 | 허용 | 키(Key)는 중복 불가 | **허용 안 함** |
| **접근 방식** | 인덱스 (`a[0]`) | 인덱스 (`a[0]`) | 키 (`a['key']`) | 직접 접근 불가 (순회만 가능) |
| **주요 용도** | 순서가 중요하고, 수정이 잦은 데이터 모음 | **수정되면 안 되는** 데이터 모음 (예: 좌표, 설정값) | 키-값 쌍으로 된 정보 (예: JSON, 개인정보) | **중복 없는** 유일한 원소들의 집합 |

#### 나. 가상 시나리오: "학생 성적 관리 프로그램"

-   **리스트**: 한 학생의 과목별 시험 점수를 순서대로 저장할 때 사용합니다. `scores = [85, 92, 78, 92]` (점수 수정 및 추가 가능)
-   **튜플**: 학생의 고유 정보처럼 **변경되면 안 되는** 데이터를 묶을 때 사용합니다. `student_id = ('2023001', '홍길동')`
-   **딕셔너리**: 학생 한 명의 상세 정보를 '키-값'으로 구조화하여 저장할 때 가장 유용합니다. `student_info = {'id': '2023001', 'name': '홍길동', 'major': 'CS'}`
-   **세트**: 특정 과목을 수강 신청한 학생들의 학번을 **중복 없이** 관리할 때 사용합니다. `enrolled_students = {'2023001', '2023005', '2023001'}` → `{'2023001', '2023005'}`로 자동 중복 제거

### 2. 오개념 분석: '얕은 복사(Shallow Copy)'와 '깊은 복사(Deep Copy)'의 함정

파이썬에서 리스트나 딕셔너리 같은 '변경 가능한(mutable)' 객체를 복사할 때, 의도치 않은 문제가 발생할 수 있습니다.

#### 가. 문제 상황: 복사본을 수정했는데 원본까지 바뀐다?

```python
a = [1, 2, ['a', 'b']]
b = a.copy()  # 얕은 복사 (Shallow Copy)

b[2][0] = 'c' # 복사본의 내부 리스트를 수정

print(f"원본 a: {a}") # 출력: 원본 a: [1, 2, ['c', 'b']] -> 원본도 변경됨!
print(f"복사본 b: {b}") # 출력: 복사본 b: [1, 2, ['c', 'b']]
```

#### 나. 원인 분석: 주소만 복사하는 '얕은 복사'

-   **얕은 복사 (`.copy()`, `list[:]`)**: 객체의 최상위 수준만 복사합니다. 리스트 안의 또 다른 리스트(예: `['a', 'b']`)는 그 내용물까지 새로 만드는 것이 아니라, **메모리 주소**만 복사해옵니다.
-   **결과**: 원본 `a`와 복사본 `b`는 서로 다른 객체이지만, 그 안에 들어있는 내부 리스트 `['a', 'b']`는 **동일한 메모리 주소를 공유**하게 됩니다. 따라서 `b`를 통해 내부 리스트를 수정하면, 같은 주소를 바라보는 `a`의 내부 리스트도 함께 변경되는 것입니다.

#### 다. 해결책: 내부까지 모두 복사하는 '깊은 복사'

-   **깊은 복사 (`copy.deepcopy()`)**: 객체 내부의 모든 객체까지 재귀적으로 찾아내어 완전히 새로운 복사본을 만듭니다.
-   **사용법**:
    ```python
    import copy

    a = [1, 2, ['a', 'b']]
    c = copy.deepcopy(a) # 깊은 복사 (Deep Copy)

    c[2][0] = 'd' # 깊은 복사본의 내부 리스트를 수정

    print(f"원본 a: {a}") # 출력: 원본 a: [1, 2, ['a', 'b']] -> 원본이 안전하게 유지됨!
    print(f"복사본 c: {c}") # 출력: 복사본 c: [1, 2, ['d', 'b']]
    ```

---


### 📝 문제

**1. 파이썬 리스트 슬라이싱의 결과는 무엇인가?](#prob-1)**
> ```python
> a = [1, 2, 3, 4, 5]
> a[1:]
> ```

<br>

**2. 파이썬 리스트 슬라이싱(음수 인덱스)의 결과는 무엇인가?](#prob-2)**
> ```python
> a = [1, 2, 3, 4, 5]
> a[:-1]
> ```

<br>

**3. 파이썬 딕셔너리 조작 후 최종 출력 결과는 무엇인가?](#prob-3)**
> ```python
> me = {'height': 180, 'weight': 70}
> me['height']
> me['weight']
> me['age'] = 30
> print(me)
> ```

<br>

**4. 파이썬 `for` 반복문과 `range()` 함수를 이용한 합계 계산 결과는 무엇인가?](#prob-4)**
> ```python
> total = 0
> for i in range(10):
>     total = total + i
> print(total)
> ```
> *(참고: 원본 문제의 `sum`은 파이썬 내장 함수이므로, 변수명 충돌을 피하기 위해 `total`로 변경하여 문제를 제시합니다.)*

<br>

**5. 파이썬 함수 정의 및 호출 결과는 무엇인가?](#prob-5)**
> ```python
> def hello(obj):
>     print("Hello " + obj + " !")
> hello("Jeong")
> ```
> *(참고: `object`는 파이썬의 예약어이므로, 변수명으로 `obj`를 사용하도록 수정했습니다.)*

<br>

**6. Numpy 배열 인덱싱 결과는 무엇인가?](#prob-6)**
> ```python
> import numpy as np
> A = np.array([[5, 7], [9, 11]])
> print(A[1, 0])
> ```

---

### 🔑 정답

1. `[2, 3, 4, 5]`
2. `[1, 2, 3, 4]`
3. `{'height': 180, 'weight': 70, 'age': 30}`
4. `45`
5. `Hello Jeong !`
6. `9`

---

### 🧐 해설

<a id="prob-1"></a>
**1. 파이썬 리스트 슬라이싱의 결과는?**
> **정답**: `[2, 3, 4, 5]`
> **해설**: 리스트 슬라이싱 `a[start:end]`에서 `start` 인덱스부터 `end-1` 인덱스까지의 원소를 반환합니다. `a[1:]`처럼 `end`가 생략되면 리스트의 끝까지를 의미합니다. 따라서 인덱스 1(두 번째 원소)부터 마지막 원소까지 반환됩니다.

<a id="prob-2"></a>
**2. 파이썬 리스트 슬라이싱(음수 인덱스)의 결과는?**
> **정답**: `[1, 2, 3, 4]`
> **해설**: 슬라이싱에서 음수 인덱스는 리스트의 끝에서부터의 위치를 의미합니다. `a[:-1]`에서 `start`가 생략되면 처음부터를, `end`가 `-1`이면 끝에서 첫 번째 원소 앞까지를 의미합니다. 따라서 첫 원소부터 마지막 원소를 제외한 모든 원소가 반환됩니다.

<a id="prob-3"></a>
**3. 파이썬 딕셔너리 조작 후 최종 출력 결과는?**
> **정답**: `{'height': 180, 'weight': 70, 'age': 30}`
> **해설**: 딕셔너리는 `key: value` 쌍으로 데이터를 저장합니다. `me['age'] = 30` 코드는 `me` 딕셔너리에 `'age'`라는 새로운 키와 `30`이라는 값을 추가합니다. `print(me)`는 딕셔너리의 최종 상태를 출력합니다.

<a id="prob-4"></a>
**4. 파이썬 `for` 반복문과 `range()` 함수를 이용한 합계 계산 결과는?**
> **정답**: `45`
> **해설**: `range(10)`은 0부터 9까지의 숫자를 생성합니다. `for` 반복문은 이 숫자들을 하나씩 `i`에 대입하며 `total = total + i` 연산을 반복 수행합니다. 결과적으로 0부터 9까지의 합인 45가 출력됩니다. (참고: `sum`은 파이썬의 내장 합계 함수이므로 변수명으로 사용하는 것을 피해야 합니다.)

<a id="prob-5"></a>
**5. 파이썬 함수 정의 및 호출 결과는?**
> **정답**: `Hello Jeong !`
> **해설**: `def hello(obj):`는 `obj`라는 매개변수를 받는 `hello` 함수를 정의합니다. `hello("Jeong")` 코드는 이 함수를 호출하면서 `"Jeong"`이라는 값을 `obj` 매개변수에 전달합니다. 함수는 전달받은 값을 이용하여 `"Hello Jeong !"`이라는 문자열을 만들어 출력합니다.

<a id="prob-6"></a>
**6. Numpy 배열 인덱싱 결과는?**
> **정답**: `9`
> **해설**: Numpy 배열에서 다차원 인덱싱은 `[행, 열]` 형식으로 접근합니다. `A[1, 0]`은 1번 행(두 번째 행), 0번 열(첫 번째 열)에 위치한 원소를 가리키므로 `9`가 반환됩니다.


---

## ✅ O/X 확인문제

**1.** [파이썬 리스트의 인덱스는 1부터 시작한다.](#ox-1) **(O / X)**
**2.** [딕셔너리(Dictionary)는 인덱스 번호를 사용하여 원소에 접근한다.](#ox-2) **(O / X)**
**3.** [튜플(Tuple)은 생성된 후에 그 내용을 수정할 수 없다.](#ox-3) **(O / X)**
**4.** [`if`문이나 `for`문에서 코드 블록을 구분하기 위해 중괄호 `{}`를 사용한다.](#ox-4) **(O / X)**
**5.** [`range(5)`는 0, 1, 2, 3, 4를 포함하는 숫자 시퀀스를 생성한다.](#ox-5) **(O / X)**
**6.** [세트(Set) 자료형은 중복된 원소를 허용하지 않는다.](#ox-6) **(O / X)**
**7.** [리스트 `a`가 있을 때, `a[-1]`은 리스트의 첫 번째 원소를 가리킨다.](#ox-7) **(O / X)**
**8.** [`True`와 `False`는 불리언(boolean) 자료형의 값이다.](#ox-8) **(O / X)**
**9.** [딕셔너리에 새로운 키-값 쌍을 추가하려면 `my_dict['new_key'] = new_value`와 같이 할당문을 사용한다.](#ox-9) **(O / X)**
**10.** [`def` 키워드는 파이썬에서 새로운 함수를 정의할 때 사용된다.](#ox-10) **(O / X)**
**11.** [리스트의 `copy()` 메서드는 리스트 내부의 리스트까지 모두 복사하는 '깊은 복사'를 수행한다.](#ox-11) **(O / X)**
**12.** [`type(10)`의 결과는 `float`이다.](#ox-12) **(O / X)**

> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: 파이썬을 포함한 많은 프로그래밍 언어에서 리스트, 튜플 등의 인덱스는 0부터 시작합니다.

> <a id="ox-2"></a>
> **2. 정답**: X
> **해설**: 딕셔너리는 순서가 아닌 고유한 '키(key)'를 사용하여 값(value)에 접근합니다. (예: `my_dict['my_key']`)

> <a id="ox-3"></a>
> **3. 정답**: O
> **해설**: 튜플은 '변경 불가능한(immutable)' 자료형으로, 한 번 생성되면 원소를 추가, 삭제, 변경할 수 없습니다.

> <a id="ox-4"></a>
> **4. 정답**: X
> **해설**: 파이썬은 들여쓰기(indentation, 보통 공백 4칸)를 사용하여 코드 블록을 구분하며, 이는 파이썬 문법의 매우 중요한 특징입니다.

> <a id="ox-5"></a>
> **5. 정답**: O
> **해설**: `range(n)`은 0부터 `n-1`까지의 정수를 생성합니다. 따라서 `range(5)`는 0, 1, 2, 3, 4를 생성합니다.

> <a id="ox-6"></a>
> **6. 정답**: O
> **해설**: 세트는 수학의 집합과 같이, 순서가 없고 중복을 허용하지 않는 원소들의 모음입니다.

> <a id="ox-7"></a>
> **7. 정답**: X
> **해설**: 음수 인덱스는 리스트의 끝에서부터 원소를 가리킵니다. `a[-1]`은 마지막 원소, `a[-2]`는 끝에서 두 번째 원소를 의미합니다.

> <a id="ox-8"></a>
> **8. 정답**: O
> **해설**: `True`와 `False`는 참과 거짓을 나타내는 불리언(bool) 타입의 두 가지 유일한 값입니다.

> <a id="ox-9"></a>
> **9. 정답**: O
> **해설**: 딕셔너리에 존재하지 않는 키에 값을 할당하면 새로운 키-값 쌍이 추가됩니다.

> <a id="ox-10"></a>
> **10. 정답**: O
> **해설**: `def`는 'define'의 약자로, 새로운 함수를 정의하는 데 사용되는 파이썬의 예약어입니다.

> <a id="ox-11"></a>
> **11. 정답**: X
> **해설**: `copy()` 메서드는 '얕은 복사(shallow copy)'를 수행합니다. 내부 객체까지 모두 복사하려면 `copy` 모듈의 `deepcopy()` 함수를 사용해야 합니다.

> <a id="ox-12"></a>
> **12. 정답**: X
> **해설**: `10`은 소수점이 없는 정수이므로 `type(10)`의 결과는 `int`입니다. `type(10.0)`의 결과가 `float`입니다.

---

## 📖 심화 학습 예시 답안

#### 1. 파이썬 자료구조, 언제 무엇을 써야 할까?

'심화 학습'에서 비교한 4가지 자료구조는 각각의 장단점이 명확하므로, 문제 상황에 맞는 최적의 도구를 선택하는 것이 중요합니다.

1.  **데이터의 불변성(Immutability)이 중요한가?**
    -   **Yes → `튜플 (Tuple)`**: 함수에서 여러 값을 반환하거나, DB 접속 정보, 좌표(x, y)처럼 프로그램 실행 중에 절대 변경되어서는 안 되는 값들을 묶어서 안전하게 관리하고 싶을 때 사용합니다.
    -   **No → `리스트 (List)`**: 순서가 중요하고, 원소의 추가, 삭제, 수정이 빈번하게 일어나는 일반적인 데이터의 모음을 다룰 때 사용합니다.

2.  **데이터를 빠르게 탐색하는 것이 중요한가?**
    -   **Yes (Key 기반 탐색) → `딕셔너리 (Dictionary)`**: 각 데이터를 고유한 '이름표(Key)'로 구분하여 저장하고, 이 이름표를 통해 값을 즉시 찾아야 할 때 사용합니다. JSON 데이터를 다루거나, 객체의 속성을 표현하는 데 최적화되어 있습니다.
    -   **Yes (원소의 존재 여부 확인) → `세트 (Set)`**: 수많은 데이터 중에서 특정 값이 존재하는지 여부만 빠르게 확인하고 싶을 때 사용합니다. 내부적으로 해시(Hash) 구조를 사용하므로 리스트보다 탐색 속도가 훨씬 빠릅니다.
    -   **No (순차 탐색으로 충분) → `리스트 (List)`**: 데이터의 양이 많지 않거나, 순서대로 하나씩 처리하는 작업이 주를 이룰 경우 사용합니다.

3.  **데이터의 유일성(Uniqueness)이 보장되어야 하는가?**
    -   **Yes → `세트 (Set)`**: 데이터 목록에서 중복을 자동으로 제거하고 유일한 값들만 모아서 관리하고 싶을 때 가장 효과적인 자료구조입니다.

#### 2. 복사의 세 가지 레벨: 할당, 얕은 복사, 깊은 복사

파이썬의 '변경 가능한(mutable)' 객체를 다룰 때, 복사 방식을 정확히 이해하지 못하면 심각한 버그를 유발할 수 있습니다.

| 방식 | 코드 예시 | 설명 | 내부 객체 공유 여부 |
| :--- | :--- | :--- | :--- |
| **할당 (Assignment)** | `b = a` | 같은 객체를 가리키는 이름(별명)만 추가합니다. `a`와 `b`는 **완전히 동일한 객체**입니다. | O (모든 객체 공유) |
| **얕은 복사 (Shallow Copy)** | `b = a.copy()` | 새로운 최상위 객체를 만들지만, 그 안의 내부 객체들은 **메모리 주소만 복사**합니다. | O (내부 객체만 공유) |
| **깊은 복사 (Deep Copy)** | `b = copy.deepcopy(a)` | 객체와 그 안의 **모든 내부 객체까지 재귀적으로 복사**하여 완전히 독립된 복사본을 만듭니다. | X (공유 없음) |

이 차이를 무시하면, 복사본을 수정하려다 원본 데이터까지 훼손하는 심각한 오류를 낳을 수 있습니다. 따라서 중첩된 리스트나 딕셔너리를 다룰 때는 의도에 맞게 `copy.deepcopy()`를 사용하는 습관을 들이는 것이 중요합니다.

#### 3. 오개념 바로잡기: "딕셔너리는 순서가 없다?"

**과거에는 맞는 말이었습니다.** 파이썬 3.6 이전 버전에서 딕셔너리는 내부적으로 해시 테이블 구조의 최적화에만 집중했기 때문에, 원소를 추가한 순서가 유지되지 않았습니다.

**하지만 지금은 틀린 말입니다.** **파이썬 3.7 버전부터 딕셔너리는 '입력 순서 유지'가 언어의 공식 사양(specification)이 되었습니다.** 즉, 딕셔너리에 키-값 쌍을 추가한 순서대로 순회(iteration)하는 것이 보장됩니다. 이 변화 덕분에 딕셔-너리는 순서가 필요한 데이터 처리 작업에서도 더욱 유용하게 사용될 수 있게 되었습니다.


---

## 🌐 최신 동향 및 추가 정보

### 1. 더 간결하고 효율적인 코드: 리스트 컴프리헨션 (List Comprehension)
`for` 반복문을 사용하여 리스트를 만드는 전통적인 방식보다 더 간결하고 가독성 높은 코드를 작성할 수 있는 **리스트 컴프리헨션** 기법이 널리 사용됩니다. 이는 '파이썬다운(Pythonic)' 코딩 스타일의 대표적인 예시입니다.

```python
# 전통적인 방식
squares = []
for i in range(10):
    squares.append(i*i)

# 리스트 컴프리헨션 방식
squares_comp = [i*i for i in range(10)]

# 조건문과 함께 사용
even_squares = [i*i for i in range(10) if i % 2 == 0]
```
리스트 컴프리헨션은 내부적으로 C언어 수준에서 최적화되어 실행되므로, 대부분의 경우 일반 `for` 루프보다 성능이 더 좋습니다.

### 2. 코드의 안정성 강화: 타입 힌팅 (Type Hinting)
파이썬은 동적 타입 언어이지만, 코드의 규모가 커질수록 변수나 함수의 데이터 타입을 명시하여 버그를 줄이고 가독성을 높이려는 요구가 커졌습니다. 파이썬 3.5부터 **타입 힌팅** 기능이 도입되어, 함수의 매개변수와 반환 값의 타입을 '힌트'로 명시할 수 있게 되었습니다.

```python
# 타입 힌팅이 없는 함수
def greeting(name):
    return 'Hello, ' + name

# 타입 힌팅이 적용된 함수
def greeting_typed(name: str) -> str:
    return 'Hello, ' + name
```
타입 힌팅은 코드 실행에 직접적인 영향을 주지는 않지만, `mypy`와 같은 정적 분석 도구나 PyCharm, VS Code 같은 최신 IDE에서 코드 실행 전에 잠재적인 타입 오류를 미리 발견할 수 있도록 도와주어 코드의 안정성을 크게 향상시킵니다.

---

## 📚 핵심 용어집 (Glossary)

-   **자료구조 (Data Structure)**: 여러 데이터를 특정 방식에 따라 효율적으로 구성하고 관리하는 구조. 파이썬의 리스트, 튜플, 딕셔너리, 세트가 이에 해당합니다.
-   **변경 가능 (Mutable)**: 객체가 생성된 후에 그 값을 수정할 수 있는 성질. 리스트, 딕셔너리, 세트가 여기에 속합니다.
-   **변경 불가능 (Immutable)**: 객체가 생성된 후에 그 값을 수정할 수 없는 성질. 정수, 실수, 문자열, 튜플이 여기에 속합니다.
-   **인덱싱 (Indexing)**: 리스트나 튜플과 같은 순서가 있는 자료구조에서 특정 위치(인덱스)의 원소를 가리키는 것. `my_list[0]`와 같이 사용합니다.
-   **슬라이싱 (Slicing)**: 순서가 있는 자료구조에서 특정 범위의 부분 집합을 추출하는 기법. `my_list[1:5]`와 같이 사용합니다.
-   **들여쓰기 (Indentation)**: 파이썬에서 코드의 논리적 블록을 구분하는 문법 규칙. `if`, `for`, `def` 등의 구문 다음에 오는 코드 블록은 반드시 들여써야 합니다.
-   **함수 (Function)**: 특정 작업을 수행하는 코드의 묶음. `def` 키워드로 정의하며, 코드의 재사용성을 높이고 프로그램을 구조화하는 데 사용됩니다.
-   **얕은 복사 (Shallow Copy)**: 객체를 복사할 때, 최상위 객체만 새로 만들고 내부의 객체들은 메모리 주소를 공유하는 방식. `copy()` 메서드나 슬라이싱(`[:]`)이 여기에 해당합니다.
-   **깊은 복사 (Deep Copy)**: 객체를 복사할 때, 내부의 모든 객체까지 재귀적으로 복사하여 완전히 독립된 새로운 객체를 만드는 방식. `copy.deepcopy()` 함수를 사용합니다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. '파이썬다운(Pythonic)' 사고방식 훈련시키기
AI가 C나 Java 스타일의 코드를 파이썬다운 코드로 개선하도록 유도하는 자료입니다.
-   **핵심**: '파이썬답다'는 것은 단순히 문법을 아는 것을 넘어, 파이썬의 철학과 기능을 가장 잘 활용하여 코드를 간결하고 명확하며 효율적으로 작성하는 것을 의미합니다.
-   **시나리오**: 사용자가 C 스타일의 인덱스 기반 `for` 루프를 작성했을 경우:
    ```python
    # Not Pythonic
    fruits = ['apple', 'banana', 'cherry']
    for i in range(len(fruits)):
        print(fruits[i])
    ```
-   **AI 답변 가이드**: AI는 이 코드를 보고, "더 파이썬다운 방법이 있습니다"라고 제안하며 다음과 같은 코드를 추천해야 합니다.
    ```python
    # Pythonic
    for fruit in fruits:
        print(fruit)
    # 인덱스가 필요하다면 enumerate() 사용
    for i, fruit in enumerate(fruits):
        print(i, fruit)
    ```
    AI는 이와 함께 `for-each` 스타일의 루프가 더 가독성이 높고, `enumerate()` 함수를 사용하면 인덱스와 값을 동시에 안전하게 얻을 수 있음을 설명하도록 유도합니다.

### 2. 견고한 코드를 위한 예외 처리(Exception Handling) 패턴 학습
AI가 프로그램 실행 중 발생하는 오류에 대처하는 방법을 안내할 수 있도록 돕는 자료입니다.
-   **핵심**: 좋은 프로그램은 오류가 발생하지 않는 프로그램이 아니라, 오류가 발생했을 때 그것을 예측하고 우아하게 처리하여 프로그램이 비정상적으로 종료되지 않도록 만드는 프로그램입니다.
-   **시나리오**: 사용자가 딕셔너리에서 존재하지 않는 키에 접근하여 `KeyError`가 발생하는 코드를 작성한 경우:
    ```python
    my_dict = {'name': 'Alice'}
    print(my_dict['age']) # KeyError 발생!
    ```
-   **AI 답변 가이드**: AI는 `KeyError`를 설명하고, 이를 처리하는 두 가지 주요 패턴을 안내해야 합니다.
    1.  **사전 확인 (LBYL: Look Before You Leap)**: 오류가 발생하기 전에 미리 확인하는 스타일. `.get()` 메서드를 사용하면 키가 없을 때 `None`이나 지정된 기본값을 반환하여 안전합니다.
        ```python
        # .get() 메서드 사용
        age = my_dict.get('age', '정보 없음') # 오류 대신 기본값 반환
        print(age)
        ```
    2.  **예외 처리 (EAFP: Easier to Ask for Forgiveness than Permission)**: 일단 실행하고, 오류가 발생하면 그때 처리하는 파이썬에서 더 권장되는 스타일. `try...except` 구문을 사용합니다.
        ```python
        # try...except 구문 사용
        try:
            print(my_dict['age'])
        except KeyError:
            print("나이 정보가 존재하지 않습니다.")
        ```
    AI는 이 두 가지 방법을 비교 설명하며, 특히 EAFP 스타일이 왜 더 파이썬다운 접근 방식인지(코드 중복 감소, 경쟁 상태 방지 등) 설명하도록 유도합니다.

---

## 📚 참고 자료 (References)

-   The Python Tutorial: 파이썬 공식 웹사이트에서 제공하는 가장 기본적이고 정확한 튜토리얼입니다.
-   PEP 8 -- Style Guide for Python Code: 모든 파이썬 개발자가 따라야 할 코드 스타일 가이드입니다.
-   Real Python: 다양한 수준의 파이썬 학습자를 위한 고품질 튜토리얼과 기사를 제공합니다.
-   파이썬 코딩 도장: 한글로 된 친절한 파이썬 입문서입니다.
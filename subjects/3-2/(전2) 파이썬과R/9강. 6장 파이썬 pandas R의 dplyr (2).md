# 9강. 6장 파이썬 pandas R의 dplyr (2)

## 학습 목표
1. R의 기본 데이터프레임 조작법과 `dplyr` 패키지의 차이점을 설명할 수 있다.
2. `dplyr`의 5가지 핵심 함수(`filter`, `select`, `arrange`, `mutate`, `summarize`)를 사용하여 데이터를 가공할 수 있다.
3. 파이프 연산자(`%>%`)를 사용하여 데이터 처리 과정을 논리적으로 연결할 수 있다.

---

## 📝 요약 (Summary)
1.  **데이터프레임과 `dplyr`**: R의 기본 `data.frame`은 데이터 분석의 핵심이지만, 복잡한 작업을 수행하기에는 문법이 번거로울 수 있습니다. 해들리 위캠이 개발한 `dplyr` 패키지는 이러한 데이터프레임 조작을 더 직관적이고 일관된 '문법'으로 처리할 수 있도록 돕는 혁신적인 도구입니다.
2.  **`dplyr`의 5가지 핵심 동사(Verbs)**: `dplyr`은 데이터 조작의 80%를 차지하는 핵심 작업을 5개의 함수로 표준화했습니다.
    -   `filter()`: 조건에 맞는 **행(row)** 선택
    -   `select()`: 원하는 **열(column)** 선택
    -   `arrange()`: 지정한 열을 기준으로 **행 정렬**
    -   `mutate()`: 기존 열을 이용해 **새로운 열 추가**
    -   `summarize()`: 데이터를 요약하여 **새로운 통계값 계산** (주로 `group_by()`와 함께 사용)
3.  **파이프 연산자 (`%>%`)**: `dplyr`의 강력함을 극대화하는 도구로, 왼쪽의 데이터(또는 결과)를 오른쪽 함수의 첫 번째 인자로 넘겨줍니다. 이를 통해 여러 단계의 데이터 처리 과정을 중간 변수 없이, 마치 물이 흐르듯 자연스럽게 연결하여 코드의 가독성을 획기적으로 높일 수 있습니다.

---

## ✏️ 심화 학습 (Study Subject)
### 1. 기본 R vs. `dplyr`: 데이터 조작의 두 가지 접근법

`dplyr`이 왜 '데이터 분석의 문법'이라 불리는지, 동일한 작업을 기본 R 함수와 `dplyr`로 각각 수행하며 비교해 봅시다.

#### 가. 가상 시나리오: "mtcars 데이터셋에서 연비(mpg)가 20 이상인 6기통(cyl) 자동차를 찾아, 연비가 높은 순으로 정렬하고, 'mpg'와 'cyl' 열만 선택하기"

-   **기본 R 접근법 (중첩된 함수, 복잡한 인덱싱)**: 안쪽부터 해석해야 하고, 인덱싱과 조건식을 섞어 써야 해 가독성이 떨어집니다.
    ```R
    # 1. 조건에 맞는 행을 찾는다.
    filtered_cars <- mtcars[mtcars$mpg >= 20 & mtcars$cyl == 6, ]
    
    # 2. 정렬 순서를 찾는다.
    ordered_cars <- filtered_cars[order(filtered_cars$mpg, decreasing = TRUE), ]
    
    # 3. 원하는 열을 선택한다.
    result <- ordered_cars[, c("mpg", "cyl")]
    ```

-   **`dplyr` 접근법 (파이프 연산자, 직관적인 동사)**: 사람의 생각 순서대로 코드를 작성할 수 있어 매우 직관적입니다.
    ```R
    library(dplyr)
    
    result <- mtcars %>%
      filter(mpg >= 20, cyl == 6) %>%      # 그리고, 연비가 20 이상이고 6기통인 차를 필터링하고
      arrange(desc(mpg)) %>%               # 그리고, 연비(mpg)를 기준으로 내림차순 정렬하고
      select(mpg, cyl)                     # 마지막으로, mpg와 cyl 열만 선택한다.
    ```

#### 나. 관점별 비교

| 관점 | 기본 R (Base R) | `dplyr` (Tidyverse) |
| :--- | :--- | :--- |
| **사고방식** | "어떤 인덱스의 어떤 데이터를 가져올까?" (컴퓨터 중심) | "데이터를 가지고 무엇을 할까?" (사람 중심) |
| **코드 구조** | 함수 중첩, 대괄호 `[]` 인덱싱 혼용 | 파이프 연산자 `%>%`를 이용한 선형적 파이프라인 |
| **가독성** | 코드가 길어지면 안쪽부터 해석해야 해 복잡함 | 왼쪽에서 오른쪽으로, 위에서 아래로 읽혀 매우 직관적 |
| **일관성** | 작업마다 다른 함수와 문법 사용 (예: `subset()`, `$`, `[]`) | `filter`, `select` 등 일관된 동사(함수) 사용 |

### 2. 오개념 분석: "파이프 연산자(`%>%`)는 그냥 코드를 예쁘게 만드는 것 아닌가요?"

-   **분석**: **아닙니다.** 파이프 연산자는 가독성 향상 외에 **중간 변수 생성을 억제**하는 중요한 역할을 합니다. 기본 R 접근법에서는 `filtered_cars`, `ordered_cars`와 같이 각 단계의 결과를 저장할 임시 변수가 필요했습니다. 이런 변수들은 작업 공간(Environment)을 어지럽히고, 나중에 재사용될 때 의도치 않은 오류를 유발할 수 있습니다. 파이프 연산자는 데이터의 흐름을 메모리 내에서 직접 연결하므로, 코드가 깔끔해질 뿐만 아니라 더 안전하고 효율적인 데이터 처리가 가능해집니다.

### 3. `group_by()`와 `summarize()`: 데이터 집계의 정수

`dplyr`의 가장 강력한 기능 중 하나는 `group_by()`와 `summarize()`의 조합입니다. 이는 데이터를 특정 그룹으로 나눈 뒤, 각 그룹별로 요약 통계량을 계산하는 **'Split-Apply-Combine'** 전략을 매우 쉽게 구현하도록 돕습니다.

-   **가상 시나리오**: "mtcars 데이터셋에서, 자동차 기어(gear) 수 별로 평균 연비(mpg)와 평균 마력(hp)은 어떻게 다른가?"
    ```R
    library(dplyr)
    
    mtcars %>%
      group_by(gear) %>%  # 1. 기어(gear) 수에 따라 3, 4, 5 그룹으로 데이터를 나눈다 (Split)
      summarize(          # 2. 각 그룹별로 요약 통계를 계산한다 (Apply)
        avg_mpg = mean(mpg),
        avg_hp = mean(hp),
        car_count = n()   # n()은 현재 그룹의 데이터 개수를 세는 특수 함수
      )                   # 3. 결과를 하나의 tibble로 합친다 (Combine)
    ```
    **실행 결과:**
    ```
    # A tibble: 3 × 4
      gear avg_mpg avg_hp car_count
     <dbl>   <dbl>  <dbl>     <int>
    1     3    16.1   176.        15
    2     4    24.5    89.5       12
    3     5    21.4   196.         5
    ```
    이처럼 단 몇 줄의 코드로 그룹별 특성을 명확하게 파악할 수 있는 것이 `dplyr`의 핵심적인 강점입니다.

---

## ❓ 연습 문제 및 해설

### 📝 문제

**1. [R에 저장된 R 시스템데이터를 가져왔다. `nwd`에서 0.9보다 큰 값을 가지는 케이스를 모두 결측치로 처리하고자 한다.](#prob-1)**
```R
load("c:/data/pyandr/lect9/wd.Rdata")
nwd = wd
head(nwd, 3)
     x1      x2      x3     x4     x5     y
1   0.573   0.1059   0.465  0.538  0.841  0.534
2   0.651   0.1356   0.527  0.545  0.887  0.535
3   0.606   0.1273   0.494  0.521  0.920  0.570
(        )
nwd[nwd == 99] = NA
```

<br>

**2. [데이터셋 `nwd`의 변수 이름을 `("a1", "a2", "a3", "a4", "a5", "newy")`으로 바꾸려고 한다.](#prob-2)**
```R
head(nwd, 3)
     x1      x2      x3     x4     x5     y
1   0.573   0.1059   0.465  0.538  0.841  0.534
2   0.651   0.1356   0.527  0.545  0.887  0.535
3   0.606   0.1273   0.494  0.521  0.920  0.570
(        ) = c("a1", "a2", "a3", "a4", "a5", "newy")
```

<br>

**3. [`insurance` 데이터셋의 변수 `job`을 (1, 2, 3)에서 ("A", "B", "C")로 바꾸고자 한다. 명령은?](#prob-3)**
 
```R
insurance = read.table("c:/Rfolder/data/insurance.txt", header=T)
head(insurance, 3)
  id sex job religion edu amount salary
1  1   m   1        1   3    7.0    110
2  2   m   2        1   4   12.0    135
3  3   f   2        3   5    8.5    127

insurance$job = (        )

head(insurance, 3)
  id sex job religion edu amount salary
1  1   m   A        1   3    7.0    110
2  2   m   B        1   4   12.0    135
3  3   f   B        3   5    8.5    127
```

<br>

**[4. `dplyr` 패키지를 이용하여 `insurance` 데이터셋에서 `sex`는 'm'이고, `edu`는 3인 데이터를 추출하고자 한다. 명령은?](#prob-4)**

```R
library(dplyr)
sel.1 = (        )
sel.1
   id sex job religion edu amount salary
1   1   m   1        1   3    7.0    110
2   5   m   1        3   3    4.5    113
3  19   m   2        3   3    7.0     85
4  22   m   3        2   3   12.0     88
```

<br>

**5. [R에 내장된 `mtcars` 데이터셋에서 `am = 0`인 데이터를 추출하고 `carb`를 기준으로 그룹화한 다음, 변수 `mpg`의 평균을 구하려고 한다. 명령은?](#prob-5)**
 
```R
cars = mtcars[, c(1, 9:11)]

cars %>% (a) %>% (b) %>% 
    summarize(mean(mpg))

  carb `mean(mpg)`
  <dbl>     <dbl>
1     1      20.3
2     2      19.3
3     3      16.3
4     4      14.3
```

<br>





<br>



---

### 🔑 정답

1. nwd[nwd>0.9] = 99
2. colnames(nwd)
3. factor(insurance$job,levels=c(1:3),labels=c("A","B","C"))
4. filter(insurance,sex=='m',edu == 3)
5. (a) = filter(am == 0),(b) = group_by(carb)


---

### 🧐 해설

<a id="prob-1"></a>
**1. 문제?**
> **정답**: `nwd[nwd > 0.9] = NA`
> **해설**: R에서 데이터프레임의 특정 조건을 만족하는 값들을 다른 값으로 바꿀 때는 논리적인 인덱싱을 사용합니다.
> - `nwd > 0.9`는 `nwd` 데이터프레임의 모든 원소를 0.9와 비교하여, 조건에 맞으면 `TRUE`, 아니면 `FALSE`인 논리형 행렬을 반환합니다.
> - `nwd[...]`와 같이 대괄호 안에 이 논리형 행렬을 넣으면 `TRUE`에 해당하는 위치의 원소들만 선택됩니다.
> - `nwd[nwd > 0.9] = NA`는 이렇게 선택된 모든 위치에 결측치(`NA`)를 할당(저장)하라는 의미입니다.
> - 문제에서 제시된 `nwd[nwd > 0.9] = 99`는 0.9보다 큰 값을 먼저 99로 바꾼 후, `nwd[nwd == 99] = NA`를 통해 다시 결측치로 바꾸는 다소 비효율적인 방식입니다. 직접 `NA`를 할당하는 것이 더 좋은 코드입니다.

<a id="prob-2"></a>
**2. 데이터셋 nwd 의 변수이름을 바꾸는 명령은?**
> **정답**: `colnames(nwd)`
> **해설**: R에서 데이터프레임의 열(column) 이름을 확인하거나 변경할 때는 `colnames()` 함수를 사용합니다.
> - `colnames(nwd)`: 현재 `nwd` 데이터프레임의 열 이름들을 벡터 형태로 반환합니다.
> - `colnames(nwd) <- c(...)`: `colnames()` 함수에 새로운 문자열 벡터를 할당하면, 데이터프레임의 열 이름이 해당 벡터의 값들로 변경됩니다.

<a id="prob-3"></a>
**3. 변수 job을 (1, 2, 3)에서 (”A“, ”B“, ”C“) 로 바꾸는 명령은?**
> **정답**: `factor(insurance$job, levels=c(1:3), labels=c("A","B","C"))`
> **해설**: R에서 숫자형 범주 데이터를 의미 있는 문자열 범주로 바꿀 때 `factor()` 함수가 매우 유용하게 사용됩니다.
> - `factor()`: 벡터를 '요인(factor)'이라는 특별한 데이터 타입으로 변환합니다. 요인은 통계 모델링에서 범주형 변수를 다룰 때 필수적입니다.
> - `levels`: 기존 데이터의 값(수준)을 지정합니다. 여기서는 `1, 2, 3`입니다.
> - `labels`: `levels`에 지정된 각 값에 대응하여 새로 부여할 문자열 라벨을 지정합니다. `1`은 `"A"`, `2`는 `"B"`, `3`은 `"C"`로 매핑됩니다.

<a id="prob-4"></a>
**4. insurance 데이터셋에서 sex 는 m 이고 , edu는 3인 데이터를 추출하는 명령은?**
> **정답**: `filter(insurance, sex == 'm', edu == 3)`
> **해설**: `dplyr` 패키지의 `filter()` 함수는 주어진 조건에 맞는 행(row)을 추출합니다.
> - `filter(데이터, 조건1, 조건2, ...)` 형태로 사용합니다.
> - 쉼표(`,`)로 여러 조건을 연결하면 **AND** 조건으로 처리됩니다. 즉, `sex`가 'm'이면서 **동시에** `edu`가 3인 행들만 선택됩니다.

<a id="prob-5"></a>
**5. am = 0 인 데이터를 추출하고 carb 를 기준으로 그룹화한 다음, 변수 mpg의 평균을 구하는 명령은?**
> **정답**: `(a) = filter(am == 0), (b) = group_by(carb)`
> **해설**: `dplyr`의 파이프 연산자(`%>%`)는 데이터 처리 과정을 순서대로 연결합니다.
> - **(a) `filter(am == 0)`**: `cars` 데이터셋에서 `am` 열의 값이 0인 행들만 먼저 필터링합니다.
> - **(b) `group_by(carb)`**: 필터링된 결과를 `carb` 열의 값에 따라 그룹으로 묶습니다.
> - `summarize(mean(mpg))`: 각 `carb` 그룹별로 `mpg` 열의 평균을 계산합니다.

---

## ✅ O/X 확인문제

**1.** [`dplyr` 패키지의 `filter()` 함수는 데이터프레임에서 특정 열(column)을 선택하는 데 사용된다.](#ox-1) **(O / X)**
**2.** R에서 파이프 연산자 `%>%`는 왼쪽 객체를 오른쪽 함수의 첫 번째 인자로 전달하는 역할을 한다. **(O / X)**
**3.** `dplyr`의 `arrange()` 함수에 `desc()`를 함께 사용하면 오름차순으로 정렬된다. **(O / X)**
**4.** `group_by()` 함수는 단독으로 사용해도 데이터에 변화를 주며, 요약 통계를 즉시 보여준다. **(O / X)**
**5.** R의 `factor()` 함수는 숫자형 데이터를 의미 있는 문자열 범주(라벨)로 변환할 때 유용하게 사용된다. **(O / X)**
**6.** `dplyr`의 `filter()` 함수 안에서 여러 조건을 쉼표(`,`)로 연결하면 OR 조건으로 처리된다. **(O / X)**
**7.** `mutate()` 함수는 기존 데이터프레임의 요약 통계량을 계산하여 새로운 데이터프레임을 만드는 데 사용된다. **(O / X)**
**8.** 데이터프레임의 열 이름을 변경하기 위해 `colnames()` 함수를 사용할 수 있다. **(O / X)**
**9.** `summarize()` 함수 내에서 `n()`을 사용하면 현재 그룹의 데이터 개수(행의 수)를 셀 수 있다. **(O / X)**
**10.** [R의 기본 인덱싱 `df[df$col > 10, ]`과 `dplyr`의 `filter(df, col > 10)`은 동일한 행을 선택하는 역할을 한다.](#ox-10) **(O / X)**


> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: `filter()` 함수는 조건에 맞는 **행(row)**을 선택(필터링)하는 데 사용됩니다. 특정 열을 선택하는 함수는 `select()`입니다.

> <a id="ox-2"></a>
> **2. 정답**: O
> **해설**: 파이프 연산자 `%>%`의 핵심 기능은 코드의 가독성을 높이기 위해, 왼쪽의 데이터 처리 결과를 오른쪽 함수의 첫 번째 인자로 자동으로 넘겨주는 것입니다.

> <a id="ox-3"></a>
> **3. 정답**: X
> **해설**: `desc()`는 '내림차순(descending)'을 의미합니다. 따라서 `arrange(desc(col))`는 해당 열을 기준으로 내림차순 정렬합니다. 오름차순은 기본값이므로 `arrange(col)`과 같이 사용합니다.

> <a id="ox-4"></a>
> **4. 정답**: X
> **해설**: `group_by()`는 데이터를 그룹으로 묶는 역할만 할 뿐, 그 자체로 데이터나 요약 통계를 보여주지 않습니다. 실제 요약 계산은 `summarize()` 함수와 함께 사용해야 의미 있는 결과를 얻을 수 있습니다.

> <a id="ox-5"></a>
> **5. 정답**: O
> **해설**: `factor()` 함수는 `levels`와 `labels` 인자를 사용하여 (1, 2, 3)과 같은 숫자 코드를 ("남", "여", "기타")와 같은 의미 있는 문자열 라벨로 효율적으로 매핑할 수 있습니다.

> <a id="ox-6"></a>
> **6. 정답**: X
> **해설**: `filter()` 함수 내에서 쉼표(`,`)는 AND 조건(`&`)과 동일하게 처리됩니다. 즉, 모든 조건을 동시에 만족하는 행만 선택합니다. OR 조건은 `|` 연산자를 사용해야 합니다.

> <a id="ox-7"></a>
> **7. 정답**: X
> **해설**: `mutate()`는 기존 열을 기반으로 **새로운 열을 추가**하는 함수입니다. 요약 통계량을 계산하여 새로운 데이터프레임을 만드는 함수는 `summarize()`입니다.

> <a id="ox-8"></a>
> **8. 정답**: O
> **해설**: `colnames(df) <- c("new1", "new2", ...)`와 같은 형식으로 데이터프레임의 전체 열 이름을 한 번에 변경할 수 있습니다.

> <a id="ox-9"></a>
> **9. 정답**: O
> **해설**: `n()`은 `summarize()`와 함께 사용되어, `group_by()`로 묶인 각 그룹에 속한 행의 개수를 계산해주는 편리한 함수입니다.

> <a id="ox-10"></a>
> **10. 정답**: O
> **해설**: 두 코드는 기능적으로 동일한 결과를 반환합니다. 하지만 `dplyr`의 `filter()`를 사용하면 파이프 연산자와 결합하여 더 읽기 좋은 코드를 작성할 수 있습니다.


---


## 📖 심화 학습 예시 답안

#### 1. `dplyr`를 사용해야 하는 이유: 코드 가독성과 사고의 전환

'심화 학습'에서 비교한 기본 R과 `dplyr`의 코드 스타일 차이는 단순히 문법의 차이를 넘어, 데이터를 다루는 사고방식의 전환을 의미합니다.

| 관점 | 기본 R (Base R) | `dplyr` (Tidyverse) |
| :--- | :--- | :--- |
| **사고방식** | **"어떤 인덱스의 어떤 데이터를 가져올까?"** (컴퓨터 중심의 절차적 사고) | **"이 데이터를 가지고 무엇을 할까?"** (사람 중심의 선언적 사고) |
| **코드 흐름** | 안쪽에서 바깥쪽으로, 또는 여러 단계로 분리됨 | 왼쪽에서 오른쪽으로, 위에서 아래로 물 흐르듯 이어짐 |
| **핵심 도구** | 대괄호 인덱싱 `[]`, 달러 기호 `$`, `subset()` 등 | 파이프 연산자 `%>%`, 5가지 핵심 동사(함수) |

1.  **절차적(Imperative) vs. 선언적(Declarative)**: 기본 R 코드는 "어떻게(How)" 데이터를 찾을지(예: `mtcars$cyl == 6`인 행의 인덱스를 찾아라)를 명시하는 절차적 방식에 가깝습니다. 반면, `dplyr` 코드는 "무엇을(What)" 원하는지(예: `filter(cyl == 6)`)를 선언하는 선언적 방식에 가깝습니다. 선언적 코드는 코드의 의도를 더 명확하게 드러내어 다른 사람이 이해하기 쉽습니다.

2.  **인지 부하 감소**: 기본 R 방식은 여러 개의 임시 변수를 만들거나 복잡한 중첩 함수를 사용해야 해서, 코드를 읽는 사람이 중간 결과들을 머릿속으로 계속 추적해야 합니다. `dplyr`의 파이프라인은 데이터의 흐름을 시각적으로 보여주므로, 각 단계가 어떤 역할을 하는지만 이해하면 전체 로직을 쉽게 파악할 수 있습니다.

#### 2. 파이프 연산자(`%>%`)의 진정한 가치: 단순한 꾸밈 그 이상

'심화 학습'에서 언급했듯이, 파이프 연산자는 단순히 코드를 예쁘게 만드는 것을 넘어, 데이터 분석의 안정성과 효율성을 높이는 중요한 역할을 합니다.

1.  **중간 변수 오염 방지 (Variable Pollution Prevention)**
    -   **문제점**: `filtered_cars`, `ordered_cars`와 같은 중간 변수들은 분석이 끝난 후에도 메모리에 남아 작업 공간(Environment)을 어지럽힙니다. 만약 나중에 다른 분석에서 같은 이름의 변수를 실수로 재사용하거나 덮어쓰면, 찾기 어려운 버그의 원인이 될 수 있습니다.
    -   **해결책**: 파이프 연산자는 데이터의 흐름을 메모리 내에서 직접 연결하므로, 불필요한 중간 변수 생성을 원천적으로 차단합니다. 이는 코드를 깔끔하게 유지하고 예기치 않은 부작용(side effect)을 줄여줍니다.

2.  **함수 조합의 유연성 (Function Composition)**
    -   파이프 연산자는 `dplyr` 함수뿐만 아니라 R의 거의 모든 함수와 함께 사용할 수 있습니다. 예를 들어, 데이터 처리 후 바로 시각화하거나 통계 모델링을 수행하는 등, 서로 다른 패키지의 기능들을 매끄럽게 연결하는 '접착제' 역할을 합니다.
    ```R
    mtcars %>%
      filter(cyl == 4) %>%      # dplyr 함수
      lm(mpg ~ wt, data = .) %>% # stats 패키지의 기본 모델링 함수. '.'은 파이프로 넘어온 데이터를 의미
      summary()                  # summary 함수
    ```

#### 3. `group_by()`와 `summarize()`: 데이터로부터 이야기 만들기

`group_by()`와 `summarize()`의 조합은 원본 데이터(raw data)를 의미 있는 정보(information)와 통찰(insight)로 바꾸는 데이터 분석의 핵심 과정입니다.

1.  **분석의 수준(Level of Analysis) 변경**: `group_by()`는 개별 관측치 수준의 데이터를 '그룹' 수준으로 집계할 수 있게 해줍니다. 예를 들어, '개별 학생'의 점수 데이터를 '학과별' 평균 점수 데이터로 변환할 수 있습니다. 이는 데이터를 더 높은 차원에서 조망하고 패턴을 발견하는 데 필수적입니다.

2.  **다양한 집계 함수 활용**: `summarize()` 내에서는 `mean()`, `sum()` 뿐만 아니라 다양한 함수를 조합하여 풍부한 요약 정보를 만들 수 있습니다.
    -   `n()`: 그룹 내 관측치 개수
    -   `n_distinct(column)`: 그룹 내 특정 열의 고유한 값 개수
    -   `mean(column)`, `sd(column)`: 평균, 표준편차
    -   `min(column)`, `max(column)`: 최솟값, 최댓값
    -   `quantile(column, 0.25)`: 특정 분위수

    ```R
    # 다이아몬드 데이터셋에서, 컷(cut) 등급별로 
    # 다이아몬드의 개수, 평균 가격, 최고 캐럿(carat) 크기를 계산
    diamonds %>%
      group_by(cut) %>%
      summarize(
        count = n(),
        avg_price = mean(price),
        max_carat = max(carat)
      )
    ```

---

## 🌐 최신 동향 및 추가 정보

### 1. 기본 R 파이프의 등장 (`|>`): `%>%`를 넘어서
R 버전 4.1.0부터 `magrittr` 패키지를 불러오지 않아도 사용할 수 있는 **기본 파이프(Native Pipe) 연산자 `|>`**가 도입되었습니다. 이는 `dplyr`의 `%>%`와 매우 유사하게 동작하지만 몇 가지 차이점이 있습니다.

```R
# magrittr 파이프 (기존 방식)
mtcars %>%
  subset(cyl == 4) %>%
  lm(mpg ~ wt, data = .) # '.'을 사용하여 파이프 데이터를 명시적으로 전달 가능

# 기본 R 파이프 (새로운 방식)
mtcars |>
  subset(cyl == 4) |>
  lm(mpg ~ wt, data = _) # R 4.2.0부터 '_'를 placeholder로 사용 가능
```

- **장점**: 별도의 패키지 설치 없이 R 기본 기능만으로 파이프라인을 구성할 수 있어 코드가 더 가벼워지고, 일부 작업에서 `%>%`보다 약간 더 빠릅니다.
- **차이점**: `%>%`는 `.`을 사용하여 파이프 데이터를 함수의 다른 위치에 전달하는 등 더 유연한 기능을 제공하지만, `|>`는 문법이 더 단순하고 제약적입니다.

최신 R 프로젝트에서는 점차 기본 파이프 `|>`의 사용이 늘어나는 추세이므로, 두 가지 파이프의 존재와 차이점을 알아두는 것이 좋습니다.

### 2. 더 빠른 데이터 처리를 향한 경쟁: `data.table`과 `dtplyr`
`dplyr`은 가독성과 사용 편의성에서 압도적인 장점을 가지지만, 수백만 행 이상의 매우 큰 데이터를 다룰 때는 `data.table` 패키지에 비해 속도가 느릴 수 있습니다.

- **`data.table`**: R에서 가장 빠른 데이터 처리 속도를 자랑하는 패키지입니다. `DT[i, j, by]`라는 고유하고 간결한 문법을 사용하여 필터링, 선택, 그룹화를 매우 효율적으로 수행합니다. 하지만 `dplyr`에 비해 문법이 직관적이지 않아 학습 곡선이 가파르다는 단점이 있습니다.

- **`dtplyr`**: `data.table`의 성능과 `dplyr`의 문법, 두 마리 토끼를 모두 잡기 위한 패키지입니다. 사용자가 `dplyr` 문법으로 코드를 작성하면, `dtplyr`가 이를 내부적으로 매우 빠른 `data.table` 코드로 변환하여 실행해 줍니다.

```R
library(dtplyr)
library(dplyr)

# lazy_dt()로 데이터를 data.table 백엔드로 전환
lazy_mtcars <- lazy_dt(mtcars)

# 코드는 dplyr과 동일하게 작성
result <- lazy_mtcars %>%
  filter(cyl > 4) %>%
  group_by(gear) %>%
  summarise(avg_mpg = mean(mpg))

# show_query()로 어떤 data.table 코드로 변환되었는지 확인 가능
show_query(result)
```

따라서, `dplyr`로 데이터 분석의 논리를 익힌 후, 성능 최적화가 필요한 시점에 `dtplyr`나 `data.table`을 학습하는 것이 효과적인 학습 경로가 될 수 있습니다.

---

## 📚 핵심 용어집 (Glossary)

-   **`dplyr`**: R에서 데이터프레임을 일관성 있고 직관적인 문법으로 조작하기 위한 핵심 패키지. '데이터 분석을 위한 문법'으로 불리며, `tidyverse` 생태계의 중심을 이룹니다.
-   **파이프 연산자 (`%>%`)**: `magrittr` 패키지에서 제공하는 연산자로, 왼쪽의 결과를 오른쪽 함수의 첫 번째 인자로 전달합니다. 여러 데이터 처리 단계를 물 흐르듯 연결하여 코드의 가독성을 획기적으로 높여줍니다.
-   **`filter()`**: `dplyr`의 함수로, 주어진 조건에 맞는 **행(row)**을 추출합니다.
-   **`select()`**: `dplyr`의 함수로, 이름으로 원하는 **열(column)**을 선택합니다.
-   **`arrange()`**: `dplyr`의 함수로, 특정 열의 값을 기준으로 행을 **정렬**합니다.
-   **`mutate()`**: `dplyr`의 함수로, 기존 열을 기반으로 **새로운 열을 추가**하거나 기존 열을 수정합니다.
-   **`group_by()`**: `dplyr`의 함수로, 특정 열(들)의 값을 기준으로 데이터프레임을 여러 그룹으로 묶습니다. 이후 `summarize()`와 함께 사용하여 그룹별 통계를 계산하는 데 주로 사용됩니다.
-   **`summarize()`**: `dplyr`의 함수로, 데이터의 요약 통계량(평균, 합계 등)을 계산하여 새로운 데이터프레임을 생성합니다.
-   **`factor()`**: R의 기본 함수로, 문자형 또는 숫자형 벡터를 '요인(factor)'이라는 범주형 데이터 타입으로 변환합니다. 통계 모델링에서 범주형 변수를 다룰 때 필수적입니다.
-   **`data.table`**: R에서 대용량 데이터를 매우 빠르게 처리하기 위한 고성능 패키지. `dplyr`에 비해 문법이 복잡하지만 속도가 빠르다는 장점이 있습니다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. `filter()` vs. 기본 R 인덱싱: 왜 `dplyr`을 써야 할까?
AI가 "R 기본 인덱싱 `df[df$col > 10, ]`으로도 필터링이 가능한데, 왜 굳이 `dplyr`의 `filter()`를 배워야 하나요?"라는 질문에 깊이 있는 답변을 생성하도록 유도하는 자료입니다.

-   **핵심**: 단순한 필터링에서는 차이가 없어 보이지만, 복잡한 데이터 처리 과정에서는 `dplyr`의 접근 방식이 압도적인 가독성과 안정성을 제공합니다.
-   **시나리오**: "mtcars 데이터셋에서, 6기통(`cyl`) 또는 8기통 차량 중, 마력(`hp`)이 150 이상이고, 기어(`gear`)가 4단이 아닌 차량을 찾아주세요."
    -   **기본 R 방식**: `mtcars[(mtcars$cyl == 6 | mtcars$cyl == 8) & mtcars$hp >= 150 & mtcars$gear != 4, ]`
    -   **`dplyr` 방식**: `filter(mtcars, (cyl == 6 | cyl == 8), hp >= 150, gear != 4)`
-   **AI 답변 가이드**:
    1.  **가독성**: `dplyr`은 여러 조건을 쉼표(`,`)로 구분하여 나열하므로, `&` 연산자를 길게 늘어놓는 것보다 훨씬 읽기 쉽다는 점을 강조합니다.
    2.  **파이프라인과의 결합**: `filter()`는 `%>%` 연산자와 함께 사용될 때 진정한 가치를 발휘합니다. 필터링 후 정렬하고, 열을 선택하는 등의 연속적인 작업을 사람의 생각 순서대로 코딩할 수 있다는 점을 설명합니다.
    3.  **프로그래밍의 용이성**: `filter()`는 함수 내에서 프로그래밍 방식으로 조건을 다루기 더 편리합니다. (예: `filter(df, .data[[col_name]] > value)`)
    4.  **일관성**: `filter()`는 `select()`, `mutate()` 등 `dplyr`의 다른 함수들과 일관된 문법 체계를 공유하므로, 데이터 조작 전체에 대한 학습 곡선을 낮춰준다는 점을 안내하도록 유도합니다.

### 2. 데이터 분석의 첫걸음: 'Tidy Data'의 개념
AI가 사용자의 데이터가 분석하기 어려운 'Untidy(지저분한)' 형태일 때, 근본적인 문제 해결책으로 'Tidy Data' 개념을 제시하고 `tidyr` 패키지 사용을 안내하도록 돕는 자료입니다.

-   **Tidy Data의 세 가지 원칙**:
    1.  모든 **열(column)**은 하나의 **변수(variable)**이다.
    2.  모든 **행(row)**은 하나의 **관측치(observation)**이다.
    3.  모든 **셀(cell)**은 하나의 **값(value)**이다.
-   **시나리오**: 사용자가 아래와 같이 'Wide' 형태의 데이터를 제시하며 "A와 B 처리 방식 간의 평균값 차이를 어떻게 구하나요?"라고 질문한 경우.
    ```
    # Untidy (Wide) Data
    patient | treatment_A | treatment_B
    -----------------------------------
    John    | 15          | 22
    Jane    | 18          | 25
    ```
-   **AI 답변 가이드**:
    1.  **문제 진단**: 현재 데이터는 `treatment_A`와 `treatment_B`라는 열 이름에 '변수(처리 방식)'의 정보가 포함되어 있어 Tidy하지 않다고 진단합니다.
    2.  **해결책 제시 (`pivot_longer`)**: `tidyr` 패키지의 `pivot_longer()` 함수를 사용하여 데이터를 'Long' 형태로 변환할 것을 제안합니다.
        ```R
        library(tidyr)
        tidy_data <- wide_data %>%
          pivot_longer(cols = c(treatment_A, treatment_B), 
                       names_to = "treatment", 
                       values_to = "value")
        ```
    3.  **Tidy Data의 장점 설명**: 변환된 Tidy 데이터는 `treatment`라는 단일 열에 그룹 정보가 모여 있으므로, `group_by()`와 `summarize()`를 사용하여 그룹별 통계를 매우 쉽게 계산할 수 있음을 보여줍니다.
        ```R
        # Tidy Data
        patient | treatment   | value
        -----------------------------
        John    | treatment_A | 15
        John    | treatment_B | 22
        Jane    | treatment_A | 18
        Jane    | treatment_B | 25
        
        # 이제 그룹별 분석이 매우 쉬워짐
        tidy_data %>%
          group_by(treatment) %>%
          summarize(avg_value = mean(value))
        ```
    이 과정을 통해 AI는 단순히 코드만 알려주는 것을 넘어, 효율적인 데이터 분석을 위한 근본적인 데이터 구조화 원칙을 사용자에게 가르칠 수 있습니다.

---

## 📚 참고 자료 (References)

-   R for Data Science (2e) - Chapter 4: Data transformation: `dplyr`의 창시자인 해들리 위캠이 집필한 책의 데이터 변환 챕터로, `dplyr`의 철학과 사용법을 가장 깊이 있게 다룹니다.
-   dplyr Vignettes: `dplyr` 공식 문서 페이지로, 각 기능에 대한 상세한 설명과 예제를 제공합니다.
-   data.table Homepage: `dplyr`의 대안으로 언급된 고성능 `data.table` 패키지의 공식 홈페이지입니다.
-   Tidy data (by Hadley Wickham): 'Tidy Data' 개념을 처음으로 정립한 해들리 위캠의 논문입니다.
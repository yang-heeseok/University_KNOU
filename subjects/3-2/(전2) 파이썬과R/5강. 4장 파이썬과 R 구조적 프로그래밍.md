# 5강. 4장 파이썬과 R 구조적 프로그래밍

## 학습 목표
1. R과 파이썬의 조건문(`if`, `else if`, `elif`)의 구조와 차이점을 설명할 수 있다.
2. R과 파이썬의 반복문(`for`, `while`)을 사용하여 반복 작업을 수행할 수 있다.
3. `break`와 `continue`/`next`를 사용하여 반복문의 흐름을 제어할 수 있다.
4. R(`function`)과 파이썬(`def`)에서 함수를 정의하고 매개변수를 활용하여 코드의 재사용성을 높일 수 있다.
5. 파이썬의 클래스(`class`)와 객체의 기본 개념을 이해하고, `__init__` 메서드를 사용하여 객체를 생성할 수 있다.

---

## 📝 요약 (Summary)
1.  **조건문 (Conditional Statement)**: 특정 조건이 참(True)일 때만 코드 블록을 실행하도록 제어합니다. R은 `if`, `else if`, `else` 구조를, 파이썬은 `if`, `elif`, `else` 구조를 사용합니다. 파이썬은 중괄호 `{}` 대신 들여쓰기(indentation)로 코드 블록을 구분하므로 각별한 주의가 필요합니다.
2.  **반복문 (Loop)**: 동일한 작업을 여러 번 반복합니다. `for`문은 리스트나 벡터 같은 시퀀스의 각 원소에 대해 반복하며, `while`문은 특정 조건이 참인 동안 계속 반복합니다. `while`문 사용 시 조건이 항상 참이 되어 무한 루프에 빠지지 않도록 주의해야 합니다.
3.  **반복 제어 (Loop Control)**: 반복문 내에서 실행 흐름을 바꿀 수 있습니다. `break`는 현재 실행 중인 반복문을 즉시 완전히 중단시킵니다. `continue`(파이썬) 또는 `next`(R)는 현재 반복의 나머지 부분을 건너뛰고 다음 반복을 시작합니다.
4.  **함수 (Function)**: 특정 기능을 수행하는 코드의 묶음으로, 코드의 재사용성을 높이고 프로그램을 구조화합니다. R에서는 `function` 키워드를, 파이썬에서는 `def` 키워드를 사용하여 함수를 정의합니다.
5.  **클래스 (Class)**: 객체 지향 프로그래밍(OOP)의 핵심 요소로, 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 하나로 묶는 '설계도'입니다. 파이썬에서는 `class` 키워드로 클래스를 정의하며, 상속을 통해 기존 클래스의 기능을 확장하거나 재사용할 수 있습니다.


---

## ✏️ 심화 학습 (Study Subject)

### 1. 함수형 프로그래밍 vs. 객체 지향 프로그래밍 (Functions vs. Classes)

함수와 클래스는 단순히 코드를 묶는 것을 넘어, 프로그램을 설계하는 두 가지 다른 철학, 즉 **절차적/함수형 프로그래밍(Procedural/Functional Programming)**과 **객체 지향 프로그래밍(Object-Oriented Programming, OOP)**을 대표합니다.

#### 가. 관점별 비교

| 관점 | 함수 중심 접근 (절차적/함수형) | 클래스 중심 접근 (객체 지향) |
| :--- | :--- | :--- |
| **핵심 단위** | **동작 (Function)** | **객체 (Object)** |
| **데이터와 동작** | 데이터와 동작(함수)이 **분리**되어 있음 | 데이터(속성)와 동작(메서드)이 객체 안에 **결합**되어 있음 |
| **상태 관리** | 상태를 직접 변경하기보다, 새로운 데이터를 생성하여 반환하는 것을 선호 (불변성 지향) | 객체가 자신의 상태(속성)를 직접 가지며, 메서드를 통해 상태를 변경 |
| **주요 언어** | R, Lisp, Haskell | Python, Java, C++ |

#### 나. 가상 시나리오: "게임 캐릭터 만들기"

-   **함수 중심 접근 (R 스타일)**: 캐릭터의 데이터(상태)와 동작(기능)을 분리하여 관리합니다.
    ```R
    # 데이터 (전역 변수 또는 리스트로 관리)
    character_hp <- 100
    character_power <- 10

    # 동작 (함수)
    attack <- function(power) {
      cat(paste("플레이어가", power, "의 힘으로 공격합니다!\n"))
    }
    get_damage <- function(hp, damage) {
      hp <- hp - damage
      return(hp) # 새로운 상태를 반환
    }
    character_hp <- get_damage(character_hp, 20) # hp = 80
    ```

-   **클래스 중심 접근 (파이썬 스타일)**: 캐릭터와 관련된 모든 데이터(hp, power)와 동작(attack, get_damage)을 `Character`라는 하나의 '설계도(class)' 안에 캡슐화합니다.
    ```python
    class Character:
        def __init__(self, hp=100, power=10):
            self.hp = hp       # 데이터 (속성, Attribute)
            self.power = power # 데이터 (속성, Attribute)

        def attack(self):      # 동작 (메서드, Method)
            print(f"플레이어가 {self.power}의 힘으로 공격합니다!")

        def get_damage(self, damage): # 동작 (메서드, Method)
            self.hp -= damage  # 객체 자신의 상태를 직접 변경
            print(f"플레이어가 {damage}의 피해를 입었습니다. 현재 HP: {self.hp}")

    player1 = Character() # 'player1'이라는 실제 객체(인스턴스) 생성
    player1.attack()
    player1.get_damage(20) # player1의 hp가 80으로 변경됨
    ```

### 2. 오개념 분석: R의 S3/S4 클래스와 파이썬의 클래스는 같다?

-   **분석**: **아닙니다.** 두 언어 모두 객체 지향 개념을 지원하지만, 구현 방식과 철학이 근본적으로 다릅니다.
    -   **R (S3/S4 클래스 - Generic-function OOP)**: R의 객체 지향은 **함수 중심**입니다. `print(my_object)`라는 동일한 함수를 호출하면, R은 `my_object`의 클래스 타입을 확인하고 그에 맞는 `print.classname()`이라는 특정 함수를 **찾아서 실행(dispatch)**해 줍니다. 즉, 객체 자체가 메서드를 가지고 있는 것이 아니라, **어떤 함수를 적용할지**가 객체의 클래스에 따라 결정됩니다.
    -   **파이썬 (클래스 - Message-passing OOP)**: 파이썬의 객체 지향은 **객체 중심**입니다. `player1.attack()` 코드는 `player1`이라는 객체에게 `attack`이라는 **메시지를 전달**하는 것과 같습니다. `attack` 메서드는 `Character` 클래스에 속해 있으며, `player1` 객체는 자신이 어떤 메서드를 가지고 있는지 명확하게 알고 있습니다.

---

## ❓ 연습 문제 및 해설

### 📝 문제

**[1. R의 if/else if 조건문에서 빈칸에 들어갈 명령은?](#prob-1)**
> ```R
> iftest2 <- function(x) {
>    if (x %% 2 == 0) {
>        cat(x, " is even number\n")
>    } (       ) (x %% 2 == 1) {
>        cat(x, " is odd number\n")
>    } else {
>        cat(x, " is not numeric\n")
>    }
> }
> ```

<br>

**[2. 파이썬의 if/elif 조건문에서 빈칸에 들어갈 명령은?](#prob-2)**
> ```python
> def if_test2(x):
>    if (x % 2 == 0):
>        print(x, " is even number")
>    (       ) (x % 2 == 1):
>        print(x, " is odd number")
>    else:
>        print(x, " is not numeric")
> ```

<br>

**[3. R의 for 반복문과 break문을 사용한 코드의 실행 결과는?](#prob-3)**
> ```R
> x <- 1:5
> for (j in x) {
>    if (j == 3) break
>    cat(j, " ")
> }
> ```

<br>


**[4. 파이썬의 for 반복문과 continue문을 사용한 코드의 실행 결과는?](#prob-4)**
> ```python
> x = range(1, 6)
> for j in x:
>      if (j == 4): continue
>      print(j, end=" ") # 결과가 한 줄에 출력되도록 end=" " 추가
> ```

<br>

**[5. 파이썬 딕셔너리에서 키를 이용해 값을 조회한 결과는?](#prob-5)**
> ```python
> country_code = {'korea': 82, 'us': 1, 'china': 86}
> print(country_code['korea'])
> ```

<br>


**[6. R 함수에서 여러 개의 계산 결과를 하나의 객체로 반환하려고 할 때, 빈칸에 들어갈 가장 적합한 함수는?](#prob-6)**
> ```R
> my_sums <- function(a=0, b=10) {
>    data <- a:b
>    sum1 <- 0; sum2 <- 0
>    for (i in data) {
>        sum1 = sum1 + i
>        sum2 = sum2 + i^2
>    } # end for-loop
>    (       )(sum1=sum1, sum2=sum2, n=length(data))
> }
> ```

<br>

**[7. 파이썬 클래스와 메서드를 정의하고 호출한 결과는?](#prob-7)**
> ```python
> class Student2:
>    def __init__(self, first, last):
>        self.first = first
>        self.last = last
> 
>    def capital_first(self):
>        return self.first.upper(), self.last.upper()
> 
> aa2 = Student2('John', 'Doe')
> aa2.capital_first()
> ```

<br>
---

### 🔑 정답

1. `else if`
2. `elif`
3. `1 2`
4. `1 2 3 5`
5. `82`
6. `list`
7. `('JOHN', 'DOE')`



---

### 🧐 해설

<a id="prob-1"></a>
**1. R의 if/else if 조건문에서 빈칸에 들어갈 명령은?**
> **정답**: `else if`
> **해설**: R에서는 여러 조건을 순차적으로 검사할 때 `if`, `else if`, `else` 구문을 사용합니다.

<a id="prob-2"></a>
**2. 파이썬의 if/elif 조건문에서 빈칸에 들어갈 명령은?**
> **정답**: `elif`
> **해설**: 파이썬에서는 `else if`를 줄여 쓴 `elif` 키워드를 사용하여 여러 조건을 순차적으로 검사합니다.

<a id="prob-3"></a>
**3. R의 for 반복문과 break문을 사용한 코드의 실행 결과는?**
> **정답**: `1 2`
> **해설**: `for` 반복문이 1부터 5까지 순회하던 중, `j`의 값이 3이 되면 `break` 문을 만나 반복문 전체가 즉시 중단됩니다. 따라서 `cat(j, " ")`는 `j`가 1과 2일 때만 실행됩니다.

<a id="prob-4"></a>
**4. 파이썬의 for 반복문과 continue문을 사용한 코드의 실행 결과는?**
> **정답**: `1 2 3 5`
> **해설**: `for` 반복문이 1부터 5까지 순회하던 중, `j`의 값이 4가 되면 `continue` 문을 만나 해당 반복의 나머지 부분(`print`)을 건너뛰고 다음 반복(j=5)으로 넘어갑니다. 따라서 4를 제외한 나머지 숫자들이 출력됩니다.

<a id="prob-5"></a>
**5. 파이썬 딕셔너리에서 키를 이용해 값을 조회한 결과는?**
> **정답**: `82`
> **해설**: 파이썬 딕셔너리는 `딕셔너리이름['키']` 형식으로 키에 해당하는 값을 조회합니다. `country_code['korea']`는 키 `'korea'`에 매핑된 값 `82`를 반환합니다.

<a id="prob-6"></a>
**6. R 함수에서 여러 개의 계산 결과를 하나의 객체로 반환하려고 할 때, 빈칸에 들어갈 가장 적합한 함수는?**
> **정답**: `list`
> **해설**: R 함수에서 여러 개의 값(특히 이름이 있는 값)을 하나의 객체로 묶어 반환할 때 `list()` 함수가 가장 일반적으로 사용됩니다. `list(sum1=sum1, sum2=sum2, n=length(data))`는 세 개의 값을 `sum1`, `sum2`, `n`이라는 이름으로 가진 **이름 있는 리스트(named list)**를 생성하여 반환합니다.
>
> **(심화)** 이 '이름 있는 리스트'는 파이썬의 **딕셔너리(Dictionary)**와 거의 동일한 역할을 합니다. R은 통계 분석 함수처럼 여러 종류의 결과(예: 계수, p-값, 모델 정보 등)를 한 번에 반환해야 하는 경우가 많기 때문에, 각 결과물에 이름표를 붙여 하나의 '묶음'으로 전달하는 이 방식이 매우 유용하게 사용됩니다. 파이썬의 `dict`처럼 이름(`$`)으로도 접근할 수 있고, 리스트의 특성상 순서(인덱스)로도 접근할 수 있습니다.
> 
> **(초보자 팁: `[[` 와 `[` 의 차이)** R에서 리스트를 다룰 때 가장 중요한 차이점입니다.
> - `[[...]]` (이중 대괄호): 리스트에서 **하나의 원소 내용물 자체**를 꺼냅니다. 결과는 숫자, 문자열, 벡터 등 원소의 원래 타입이 됩니다.
> - `[...]` (단일 대괄호): 리스트를 **부분집합(subset)**하여, 결과는 **항상 리스트**가 됩니다.
> 예를 들어, `results <- list(total_sum = 15, count = 5)`가 있을 때, `results[[1]]`은 숫자 `15`를 반환하지만, `results[1]`은 `total_sum`이라는 이름을 가진, 원소 하나짜리 `리스트`를 반환합니다.

<a id="prob-7"></a>
**7. 파이썬 클래스와 메서드를 정의하고 호출한 결과는?**
> **정답**: `('JOHN', 'DOE')`
> **해설**: `aa2 = Student2('John', 'Doe')`는 `__init__` 메서드를 호출하여 `first`와 `last` 속성을 가진 `aa2` 객체를 생성합니다. `aa2.capital_first()`는 이 객체의 메서드를 호출하여 `self.first`('John')와 `self.last`('Doe')를 대문자로 변환한 후, 두 개의 문자열을 담은 튜플 `('JOHN', 'DOE')`를 반환합니다.

---

## ✅ O/X 확인문제

**1.** [파이썬에서 여러 조건을 순차적으로 검사할 때 `else if` 키워드를 사용한다.](#ox-1) **(O / X)**
**2.** [`while` 반복문은 주어진 조건이 `False`가 될 때까지 계속 실행된다.](#ox-2) **(O / X)**
**3.** [`break` 문은 현재 실행 중인 반복문의 나머지 부분을 건너뛰고 다음 반복을 시작한다.](#ox-3) **(O / X)**
**4.** [R의 `next`와 파이썬의 `continue`는 반복문 내에서 동일한 역할을 수행한다.](#ox-4) **(O / X)**
**5.** [파이썬에서 함수를 정의할 때는 `function` 키워드를 사용한다.](#ox-5) **(O / X)**
**6.** [파이썬 클래스에서 객체가 생성될 때 자동으로 호출되는 생성자 메서드는 `__init__`이다.](#ox-6) **(O / X)**
**7.** [R과 파이썬 모두 `if`문이나 `for`문의 코드 블록을 구분하기 위해 들여쓰기를 사용한다.](#ox-7) **(O / X)**
**8.** [`while True:` 구문은 내부에 `break` 문이 없다면 무한히 반복된다.](#ox-8) **(O / X)**
**9.** [클래스는 실제 메모리에 생성된 실체이고, 객체는 그 실체를 만들기 위한 설계도이다.](#ox-9) **(O / X)**
**10.** [파이썬 클래스의 메서드를 정의할 때, 첫 번째 매개변수로 항상 `self`를 사용하여 객체 자신을 참조해야 한다.](#ox-10) **(O / X)**
**11.** [R에서 함수를 정의할 때는 `def` 키워드를 사용한다.](#ox-11) **(O / X)**
**12.** [파이썬의 `for`문은 리스트, 튜플, 문자열 등 반복 가능한(iterable) 객체에 사용할 수 있다.](#ox-12) **(O / X)**

> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: 파이썬에서는 `else if` 대신 `elif`라는 축약된 키워드를 사용합니다.

> <a id="ox-2"></a>
> **2. 정답**: O
> **해설**: `while`문은 조건이 `True`인 동안 반복을 계속하고, 조건이 `False`가 되면 반복을 멈춥니다.

> <a id="ox-3"></a>
> **3. 정답**: X
> **해설**: `break`는 반복문을 즉시 완전히 중단시킵니다. 현재 반복을 건너뛰고 다음 반복으로 넘어가는 것은 `continue`(파이썬) 또는 `next`(R)입니다.

> <a id="ox-4"></a>
> **4. 정답**: O
> **해설**: 두 키워드 모두 현재 반복의 나머지 코드를 실행하지 않고 다음 반복으로 넘어가는 역할을 합니다.

> <a id="ox-5"></a>
> **5. 정답**: X
> **해설**: 파이썬에서는 `def` 키워드를 사용하여 함수를 정의합니다. `function`은 R에서 사용하는 키워드입니다.

> <a id="ox-6"></a>
> **6. 정답**: O
> **해설**: `__init__` 메서드는 클래스로부터 객체(인스턴스)가 생성될 때 호출되어 객체의 초기 상태(속성)를 설정하는 역할을 합니다.

> <a id="ox-7"></a>
> **7. 정답**: X
> **해설**: 파이썬은 들여쓰기로 코드 블록을 구분하지만, R은 중괄호 `{}`를 사용하여 코드 블록을 명시적으로 구분합니다.

> <a id="ox-8"></a>
> **8. 정답**: O
> **해설**: `True`는 항상 참이므로, `while True:` 구문은 무한 루프를 만듭니다. 이를 탈출하기 위해서는 반드시 `break` 문이 필요합니다.

> <a id="ox-9"></a>
> **9. 정답**: X
> **해설**: 반대로, 클래스(Class)가 '설계도'이고, 그 설계도를 바탕으로 메모리에 만들어진 실체가 객체(Object) 또는 인스턴스(Instance)입니다.

> <a id="ox-10"></a>
> **10. 정답**: O
> **해설**: 클래스 내에 정의된 메서드의 첫 번째 매개변수는 관례적으로 `self`를 사용하여, 메서드를 호출한 객체 자신을 가리키도록 약속되어 있습니다.

> <a id="ox-11"></a>
> **11. 정답**: X
> **해설**: R에서는 `function` 키워드를 사용하여 함수를 정의합니다. (예: `my_func <- function(x) { ... }`)

> <a id="ox-12"></a>
> **12. 정답**: O
> **해설**: `for`문은 원소들을 하나씩 순회할 수 있는 모든 종류의 iterable 객체(리스트, 튜플, 딕셔너리, 문자열, range 등)와 함께 사용할 수 있습니다.

---

## 📖 심화 학습 예시 답안

#### 1. 함수형 vs. 객체 지향, 언제 무엇을 선택할까?

함수와 클래스는 단순히 코드를 묶는 도구가 아니라, 문제를 바라보는 두 가지 다른 관점입니다. 상황에 맞는 패러다임을 선택하면 더 효율적이고 유지보수가 쉬운 코드를 작성할 수 있습니다.

1.  **데이터와 기능의 결합도 (Coupling)**: 데이터와 그 데이터를 처리하는 기능이 얼마나 밀접하게 관련되어 있는가?
    -   **객체 지향 (클래스) 추천**: 데이터(속성)와 그 데이터를 조작하는 기능(메서드)이 강하게 결합되어 있을 때. 예를 들어, '은행 계좌'는 '잔액'이라는 데이터와 '입금', '출금'이라는 기능이 분리될 수 없습니다. 이를 `Account` 클래스로 묶으면 데이터와 관련 동작을 함께 캡슐화하여 코드의 안정성과 이해도를 높일 수 있습니다.
    -   **함수형 추천**: 데이터 변환 파이프라인처럼, 범용적인 기능들을 다양한 종류의 데이터에 순차적으로 적용할 때. 예를 들어, `데이터 읽기 → 결측치 제거 → 정규화 → 모델 학습`과 같은 일련의 독립적인 단계를 함수로 정의하고 연결하면, 각 단계의 재사용성이 높아지고 테스트가 용이해집니다. R의 `tidyverse` 패키지들이 대표적인 함수형 프로그래밍 스타일입니다.

2.  **상태 관리의 복잡성 (State Management)**: 프로그램이 시간의 흐름에 따라 얼마나 많은 상태를 기억하고 변경해야 하는가?
    -   **객체 지향 (클래스) 추천**: 여러 속성들이 상호작용하며 복잡한 상태를 유지해야 할 때. 예를 들어, GUI 애플리케이션의 '버튼' 객체는 자신의 '색상', '크기', '활성화 여부' 등 다양한 상태를 스스로 관리해야 합니다. 클래스는 이러한 상태들을 객체 내부에 안전하게 보관하는 역할을 합니다.
    -   **함수형 추천**: 상태 변화를 최소화하여 예측 가능성을 높이고 싶을 때. 함수형 프로그래밍에서는 원본 데이터를 직접 수정하는 대신, 연산 결과를 새로운 데이터로 반환하는 '불변성(Immutability)'을 지향합니다. 이는 데이터의 흐름을 추적하기 쉽게 만들고, 특히 병렬 처리 환경에서 예기치 않은 부작용(Side Effect)을 방지하는 데 매우 효과적입니다.

#### 2. R과 파이썬의 객체 지향, 철학의 차이

'심화 학습'에서 언급된 R과 파이썬의 OOP 차이는 "누가 행동을 결정하는가?"라는 관점에서 이해할 수 있습니다.

| 구분 | R (S3/S4 시스템) | 파이썬 (표준 클래스 시스템) |
| :--- | :--- | :--- |
| **핵심 철학** | **"함수가 객체를 보고 행동을 결정한다."** (Generic-function OOP) | **"객체가 메시지를 받고 스스로 행동한다."** (Message-passing OOP) |
| **동작 방식** | `print(my_data)`를 호출하면, `print`라는 일반 함수(Generic Function)가 `my_data`의 클래스를 확인하고, 그에 맞는 `print.classname`이라는 특정 메서드를 **찾아서 실행(dispatch)**합니다. | `my_data.print()`를 호출하면, `my_data` 객체에게 `print`라는 **메시지를 전달**하고, 객체는 자신이 가지고 있는 `print` 메서드를 직접 실행합니다. |
| **비유** | 의사가 환자(객체)의 차트(클래스)를 보고 어떤 처방(메서드)을 내릴지 결정하는 것과 같습니다. | 환자(객체)가 "치료해줘"라는 요청(메시지)을 받으면, 스스로 자신의 몸에 맞는 치료법(메서드)을 수행하는 것과 같습니다. |
| **실제 모습** | `print()`, `summary()`, `plot()` 등 동일한 이름의 함수가 다양한 클래스의 객체에 적용됩니다. | `df.head()`, `model.fit()`, `fig.show()` 등 각 객체가 자신만의 고유한 메서드를 호출하는 형태가 일반적입니다. |

이러한 차이 때문에 R은 통계 분석처럼 데이터에 다양한 분석 함수를 적용하는 데 자연스러운 구조를 가지며, 파이썬은 독립적인 역할을 수행하는 여러 객체들이 상호작용하는 복잡한 소프트웨어를 구축하는 데 더 적합한 구조를 가집니다.

#### 3. 오개념 바로잡기: "클래스는 항상 함수보다 좋다?"

**아닙니다.** 객체 지향 프로그래밍(OOP)이 현대 소프트웨어 공학의 주류 패러다임인 것은 사실이지만, 이것이 모든 상황에서 최선이라는 의미는 아닙니다. 간단한 데이터 처리나 수학적 연산 스크립트의 경우, 불필요하게 클래스를 도입하면 코드가 더 복잡해지고 장황해질 수 있습니다. 오히려 순수한 함수들로 구성된 코드가 더 직관적이고 테스트하기 쉬울 수 있습니다. 중요한 것은 문제의 복잡도와 성격에 맞춰 함수와 클래스라는 두 가지 도구를 적재적소에 활용하는 능력입니다.


---

## 🌐 최신 동향 및 추가 정보

### 1. 코드의 재사용성 극대화: 데코레이터 (Decorator)
**데코레이터**는 기존 함수의 코드를 수정하지 않으면서, 함수에 새로운 기능을 추가하거나 동작을 변경할 수 있게 해주는 강력한 기능입니다. `@` 기호를 사용하여 함수 위에 적용하며, 주로 로깅, 실행 시간 측정, 접근 제어 등 여러 함수에 공통적으로 적용되어야 하는 부가 기능(Cross-cutting concern)을 구현하는 데 널리 사용됩니다.

```python
import time

def timer(func):
    """함수의 실행 시간을 측정하는 데코레이터"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"'{func.__name__}' 함수 실행 시간: {end_time - start_time:.4f}초")
        return result
    return wrapper

@timer # 데코레이터 적용
def my_long_running_function():
    """시간이 오래 걸리는 작업을 시뮬레이션하는 함수"""
    time.sleep(2)

my_long_running_function()
# 출력: 'my_long_running_function' 함수 실행 시간: 2.00xx초
```

### 2. 간결한 클래스 정의: 데이터클래스 (Dataclasses)
파이썬 3.7부터 도입된 **데이터클래스**는 주로 데이터를 저장하는 용도의 클래스를 매우 간결하게 작성할 수 있도록 도와줍니다. `@dataclass` 데코레이터를 클래스 위에 붙이면, `__init__`, `__repr__` (객체 출력 형식), `__eq__` (객체 비교) 등 번거로운 기본 메서드들을 자동으로 생성해 줍니다.

```python
from dataclasses import dataclass

# 일반적인 클래스 정의
class InventoryItem:
    def __init__(self, name: str, unit_price: float, quantity_on_hand: int = 0):
        self.name = name
        self.unit_price = unit_price
        self.quantity_on_hand = quantity_on_hand

# 데이터클래스를 사용한 정의
@dataclass
class InventoryItemData:
    name: str
    unit_price: float
    quantity_on_hand: int = 0

item1 = InventoryItemData("Laptop", 1500.0, 5)
print(item1) # 출력: InventoryItemData(name='Laptop', unit_price=1500.0, quantity_on_hand=5)
```

---

## 📚 핵심 용어집 (Glossary)

-   **제어문 (Control Flow)**: 코드의 실행 순서나 흐름을 제어하는 구문. 조건문(`if`)과 반복문(`for`, `while`)이 대표적입니다.
-   **함수 (Function)**: 특정 작업을 수행하도록 설계된 재사용 가능한 코드 블록. R에서는 `function`, 파이썬에서는 `def`로 정의합니다.
-   **클래스 (Class)**: 객체를 만들기 위한 '설계도' 또는 '틀'. 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 함께 묶어 정의합니다.
-   **객체 (Object / Instance)**: 클래스라는 설계도를 바탕으로 메모리에 실제로 생성된 실체. 자신만의 속성 값을 가질 수 있습니다.
-   **속성 (Attribute)**: 클래스나 객체에 속한 변수. 객체의 상태나 데이터를 나타냅니다. (예: `player.hp`)
-   **메서드 (Method)**: 클래스 내에 정의된 함수. 해당 클래스의 객체를 통해서만 호출할 수 있으며, 객체의 동작을 정의합니다. (예: `player.attack()`)
-   **`__init__` (생성자)**: 파이썬 클래스에서 객체가 생성될 때 자동으로 호출되는 특별한 메서드. 객체의 초기 속성을 설정하는 데 사용됩니다.
-   **`self`**: 파이썬 클래스의 메서드 내에서, 메서드를 호출한 객체 자신을 가리키는 관례적인 이름. 이를 통해 객체의 속성이나 다른 메서드에 접근할 수 있습니다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. 유연한 함수 설계를 위한 마법: `*args`와 `**kwargs`
AI가 "함수에 몇 개의 인자를 전달해야 할지 모를 때 어떻게 하나요?"라는 질문에 깊이 있는 답변을 생성하도록 유도하는 자료입니다.
-   **핵심**: 파이썬 함수는 `*args`와 `**kwargs` 문법을 사용하여 정해지지 않은 개수의 인자들을 유연하게 받을 수 있습니다.
-   **`*args` (arguments)**: 여러 개의 위치 인자(positional arguments)를 **튜플(tuple)** 형태로 받습니다.
-   **`**kwargs` (keyword arguments)**: 여러 개의 키워드 인자(keyword arguments)를 **딕셔너리(dictionary)** 형태로 받습니다.
-   **시나리오**: 어떤 종류의 정보든 기록할 수 있는 범용 로깅 함수를 만들어야 하는 상황.
    ```python
    def flexible_logger(log_level, *args, **kwargs):
        print(f"[{log_level.upper()}]")
        
        # 위치 인자들 출력
        for arg in args:
            print(f"- {arg}")
            
        # 키워드 인자들 출력
        for key, value in kwargs.items():
            print(f"- {key}: {value}")

    flexible_logger("info", "Server started", "Another message")
    flexible_logger("debug", user_id=123, action="login", ip_address="192.168.1.1")
    ```
-   **AI 답변 가이드**: 사용자가 가변 인자에 대해 질문하면, `*args`는 튜플, `**kwargs`는 딕셔너리로 묶인다는 점을 명확히 설명하고, 위와 같은 예시를 통해 데코레이터나 프레임워크 등에서 내부적으로 함수를 호출할 때 매우 유용하게 사용됨을 안내하도록 유도합니다.

### 2. 코드 재사용의 정수: 상속과 다형성 (Inheritance & Polymorphism)
AI가 객체 지향 프로그래밍의 핵심 가치인 '코드 재사용'과 '확장성'을 설명할 수 있도록 돕는 자료입니다.
-   **상속 (Inheritance)**: 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 그대로 사용하거나, 새로운 기능을 추가/변경(오버라이딩)하여 사용하는 것입니다. 코드의 중복을 줄여줍니다.
-   **다형성 (Polymorphism)**: 서로 다른 클래스의 객체들이 동일한 이름의 메서드 호출에 대해 각자의 방식대로 다르게 반응하는 성질입니다. 코드의 유연성과 확장성을 높여줍니다.
-   **시나리오**: 다양한 종류의 동물을 관리하는 프로그램.
    ```python
    class Animal:  # 부모 클래스
        def __init__(self, name):
            self.name = name
        
        def speak(self): # 공통 동작의 기본 형태
            raise NotImplementedError("Subclass must implement this method")

    class Dog(Animal): # 자식 클래스 (상속)
        def speak(self): # 메서드 오버라이딩
            return f"{self.name} says Woof!"

    class Cat(Animal): # 자식 클래스 (상속)
        def speak(self): # 메서드 오버라이딩
            return f"{self.name} says Meow!"

    animals = [Dog("Buddy"), Cat("Lucy")]

    for animal in animals:
        # 다형성: animal 객체가 Dog이든 Cat이든 상관없이 동일하게 speak()를 호출할 수 있음
        print(animal.speak()) 
    ```
-   **AI 답변 가이드**: 사용자가 상속에 대해 질문하면, 단순히 '물려받는 것'이라고 설명하는 것을 넘어, 위 예시처럼 `Animal`이라는 공통점을 묶어 코드 중복을 피하고, `Dog`과 `Cat`이 `speak()`라는 동일한 요청에 다르게 반응하는 '다형성'을 통해, 나중에 `Bird`라는 새로운 클래스를 추가하더라도 기존 코드를 수정할 필요 없이 시스템을 쉽게 확장할 수 있다는 장점을 함께 설명하도록 유도합니다.

---

## 📚 참고 자료 (References)

-   Python Official Docs: `if` Statements: 파이썬 공식 문서의 조건문 설명
-   Python Official Docs: `for` Statements: 파이썬 공식 문서의 for 반복문 설명
-   Python Official Docs: Defining Functions: 파이썬 공식 문서의 함수 정의 설명
-   Python Official Docs: Classes: 파이썬 공식 문서의 클래스 정의 설명
-   Real Python: Object-Oriented Programming (OOP) in Python 3: 파이썬 객체 지향 프로그래밍에 대한 심층 튜토리얼
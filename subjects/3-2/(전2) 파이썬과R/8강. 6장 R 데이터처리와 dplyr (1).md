# 8강. 6장 R 데이터처리와 dplyr (1)

## 학습 목표
1. Pandas의 Series와 DataFrame 자료구조의 개념과 차이점을 설명할 수 있다.
2. 리스트, 딕셔너리, Numpy 배열을 사용하여 Series와 DataFrame을 생성할 수 있다.
3. `loc`과 `iloc`을 사용하여 DataFrame의 특정 행과 열을 선택하고 수정할 수 있다.
4. `statsmodels` 라이브러리를 이용해 R의 내장 데이터셋을 파이썬으로 불러올 수 있다.

---

## 📝 요약 (Summary)
1.  **Pandas 소개**: Pandas는 R의 `data.frame`에 영감을 받아 개발된 파이썬 데이터 분석 라이브러리입니다. 테이블 형태의 데이터를 다루기 위한 강력하고 효율적인 도구를 제공하며, 보통 `import pandas as pd`와 같이 `pd`라는 별칭으로 사용합니다.
2.  **핵심 자료구조**: Pandas는 두 가지 핵심 자료구조를 가집니다.
    -   **Series**: 값(values)과 인덱스(index)로 구성된 1차원 배열. DataFrame의 한 열에 해당합니다.
    -   **DataFrame**: 행(row)과 열(column)으로 구성된 2차원 테이블. 데이터 분석 작업의 중심이 됩니다.
3.  **데이터 생성**: 파이썬의 기본 자료구조(리스트, 딕셔너리)나 Numpy 배열을 사용하여 Series와 DataFrame을 쉽게 생성할 수 있습니다. 특히 딕셔너리를 사용하면 키가 열의 이름이 되어 직관적인 생성이 가능합니다.
4.  **데이터 입출력**: CSV, Excel, SQL 등 다양한 파일 포맷을 읽고 쓰는 강력한 기능을 제공합니다. (예: `pd.read_csv()`, `df.to_excel()`)
5.  **데이터 선택**: DataFrame에서 원하는 데이터를 선택하는 다양한 방법을 제공합니다.
    -   **`df['col_name']`**: 특정 열을 선택합니다.
    -   **`df.loc[...]`**: 레이블(이름) 기반으로 행/열을 선택합니다.
    -   **`df.iloc[...]`**: 정수 위치 기반으로 행/열을 선택합니다.
6.  **R 데이터 연동**: `statsmodels`와 같은 라이브러리를 사용하면 R의 수많은 내장 데이터셋을 파이썬의 Pandas DataFrame으로 직접 불러와 분석에 활용할 수 있습니다.

---

## ✏️ 심화 학습 (Study Subject)

1.  [Pandas 인덱싱 완전 정복: `loc`, `iloc`, 그리고 경고 메시지]
2.  [깔끔한 Pandas 코드를 위한 메서드 체이닝 (Method Chaining)]
3.  [데이터 집계의 정수: `groupby`와 Split-Apply-Combine 전략]

---


## ❓ 연습 문제 및 해설

### 📝 문제

**1. Pandas Series로 DataFrame을 생성했을 때의 출력 결과는?](#prob-1)**
> ```python
> import numpy as np
> import pandas as pd
> s = pd.Series([10, 20, 30], index=['a', 'b', 'c'])
> df = pd.DataFrame(s, columns=["A"])
> print(df)
> ```

<br>

**2. Pandas DataFrame을 Numpy 배열로 변환하려고 할 때, 빈칸에 들어갈 메서드는?](#prob-2)**
> ```python
> import numpy as np
> import pandas as pd
> s = pd.Series([10, 20, 30], index=['a', 'b', 'c'])
> df = pd.DataFrame(s, columns=["A"])
> arr = df.(           )
> print(type(arr))
> ```

<br>

**3. Series를 값으로 갖는 딕셔너리를 DataFrame으로 변환하려고 할 때, 빈칸에 들어갈 명령어는?](#prob-3)**
> ```python
> import pandas as pd
> d = {
>     'one': pd.Series([1, 2], index=['a', 'b']),
>     'two': pd.Series([1, 2, 3], index=['a', 'b', 'c'])
> }
> df = (        )
> print(df)
> ```

<br>

**4. `statsmodels` 라이브러리를 사용하여 R의 내장 데이터셋을 불러오려고 할 때, 빈칸에 들어갈 명령어는?](#prob-4)**
> ```python
> import statsmodels.api as sm
> trees = (        )
> print(trees.head())
> ```

<br>


---

### 🔑 정답

1. `   A\na 10\nb 20\nc 30` (또는 유사한 형태의 텍스트 출력)
2. `to_numpy()`
3. `pd.DataFrame(d)`
4. `sm.datasets.get_rdataset("trees")['data']`

---

### 🧐 해설

<a id="prob-1"></a>
**1. Pandas Series로 DataFrame을 생성했을 때의 출력 결과는?**
> **정답**: `   A\na 10\nb 20\nc 30`
> **해설**: Pandas Series `s`를 기반으로 `df`라는 이름의 DataFrame을 생성했습니다. `columns=["A"]` 옵션으로 열의 이름을 'A'로 지정했습니다. `print(df)`는 DataFrame의 내용을 텍스트 형식으로 콘솔에 출력합니다. 인덱스('a', 'b', 'c')와 각 인덱스에 해당하는 'A'열의 값이 함께 표시됩니다.

<a id="prob-2"></a>
**2. Pandas DataFrame을 Numpy 배열로 변환하는 메서드는?**
> **정답**: `to_numpy()`
> **해설**: `to_numpy()`는 Pandas DataFrame이나 Series를 Numpy의 `ndarray` 객체로 변환하는 공식적인 메서드입니다. 이 변환을 통해 Numpy가 제공하는 빠르고 효율적인 수치 연산을 데이터에 적용할 수 있습니다.

<a id="prob-3"></a>
**3. 딕셔너리를 DataFrame으로 변환하는 명령어는?**
> **정답**: `pd.DataFrame(d)`
> **해설**: Pandas의 `DataFrame()` 생성자는 딕셔너리를 인자로 받을 수 있습니다. 이때 딕셔너리의 키는 DataFrame의 열(column) 이름이 되고, 값(Series)은 각 열의 데이터가 됩니다. Pandas는 각 Series의 인덱스를 기준으로 데이터를 정렬하며, 한쪽에만 존재하는 인덱스(이 경우 'c')의 값은 `NaN`(Not a Number)으로 채워집니다.

<a id="prob-4"></a>
**4. `statsmodels`를 사용하여 R 데이터셋을 불러오는 명령어는?**
> **정답**: `sm.datasets.get_rdataset("trees")['data']`
> **해설**: `statsmodels` 라이브러리의 `get_rdataset()` 함수는 R의 특정 패키지에 포함된 데이터셋을 불러오는 기능을 제공합니다. 이 함수는 데이터와 메타정보를 포함한 객체를 반환하므로, 실제 데이터프레임에 접근하기 위해서는 `['data']`를 사용해야 합니다.

---

## ✅ O/X 확인문제

**1.** [Pandas Series는 R의 벡터와 같이 값에 대응하는 인덱스를 가질 수 있다.](#ox-1) **(O / X)**
**2.** [딕셔너리를 사용하여 Pandas DataFrame을 생성할 때, 딕셔너리의 키(key)는 DataFrame의 행(row) 이름이 된다.](#ox-2) **(O / X)**
**3.** [`df.to_numpy()` 메서드는 Pandas DataFrame을 파이썬의 기본 리스트(list)로 변환한다.](#ox-3) **(O / X)**
**4.** [인덱스가 서로 다른 여러 Series로 DataFrame을 만들면, 겹치지 않는 인덱스의 값은 0으로 채워진다.](#ox-4) **(O / X)**
**5.** [Pandas라는 이름은 "Panel Data Analysis"에서 유래했다.](#ox-5) **(O / X)**
**6.** [`statsmodels` 라이브러리를 사용하면 R의 내장 데이터셋을 파이썬으로 직접 불러올 수 있다.](#ox-6) **(O / X)**
**7.** [Pandas DataFrame의 모든 열(column)은 반드시 동일한 데이터 타입을 가져야 한다.](#ox-7) **(O / X)**
**8.** [Pandas Series의 인덱스는 중복된 값을 가질 수 없다.](#ox-8) **(O / X)**

> <a id="ox-1"></a>
> **1. 정답**: O
> **해설**: Pandas의 Series는 Numpy 배열과 유사한 값(values)과 그 값에 대응하는 인덱스(index)로 구성된 1차원 자료구조입니다.

> <a id="ox-2"></a>
> **2. 정답**: X
> **해설**: 딕셔너리의 키는 DataFrame의 열(column) 이름이 됩니다. 딕셔너리의 값(리스트 또는 Series)이 각 열의 데이터가 됩니다.

> <a id="ox-3"></a>
> **3. 정답**: X
> **해설**: `to_numpy()` 메서드는 DataFrame을 Numpy의 `ndarray` 객체로 변환합니다. 이를 통해 고성능 수치 연산을 수행할 수 있습니다.

> <a id="ox-4"></a>
> **4. 정답**: X
> **해설**: Pandas는 인덱스를 기준으로 데이터를 정렬하며, 한쪽에만 존재하는 인덱스의 값은 `NaN`(Not a Number)으로 채워집니다.

> <a id="ox-5"></a>
> **5. 정답**: O
> **해설**: Pandas는 다차원 시계열 데이터인 '패널 데이터(Panel Data)'를 효율적으로 분석하기 위해 개발되었으며, 그 이름도 여기에서 유래했습니다.

> <a id="ox-6"></a>
> **6. 정답**: O
> **해설**: `statsmodels.api.datasets.get_rdataset()` 함수를 사용하면 R의 수많은 내장 데이터셋을 Pandas DataFrame 형태로 쉽게 불러와 분석에 활용할 수 있습니다.

> <a id="ox-7"></a>
> **7. 정답**: X
> **해설**: DataFrame의 각 열은 독립적인 Series 객체이므로, 열마다 서로 다른 데이터 타입(예: 한 열은 숫자, 다른 열은 문자열)을 가질 수 있습니다. 이것이 모든 원소의 타입이 같아야 하는 행렬(matrix)과의 중요한 차이점입니다.

> <a id="ox-8"></a>
> **8. 정답**: X
> **해설**: Pandas Series의 인덱스는 중복된 값을 허용합니다. 하지만 인덱스가 중복될 경우 특정 작업을 수행할 때 예기치 않은 결과가 발생할 수 있어 주의가 필요합니다.

---

## 📖 심화 학습 예시 답안

#### 1. Pandas 인덱싱 완전 정복: `loc`, `iloc`, 그리고 경고 메시지

Pandas에서 데이터에 접근하는 `loc`과 `iloc`은 명확한 사용 기준이 있으며, 이를 이해하는 것이 중요합니다.

1.  **접근 기준: 이름(Label)인가, 위치(Position)인가?**
    -   **`loc` (Label-based)**: **인덱스 이름(label)이나 열 이름(column name)**으로 데이터에 접근할 때 사용합니다. 코드가 명시적이고, 데이터의 순서가 바뀌어도 의도한 대로 동작하므로 더 안전합니다.
    -   **`iloc` (Integer position-based)**: **정수 위치(0부터 시작)**로 데이터에 접근할 때 사용합니다. Numpy 배열처럼 프로그래밍 방식으로 순서에 따라 접근할 때 유용합니다.

2.  **슬라이싱 동작: 끝을 포함하는가, 제외하는가?**
    -   **`loc`**: 슬라이싱 시 **끝 지점을 포함**합니다. `df.loc['a':'c']`는 'a', 'b', 'c' 행을 모두 포함합니다.
    -   **`iloc`**: 슬라이싱 시 **끝 지점을 제외**합니다. `df.iloc[0:3]`은 0, 1, 2 위치의 행을 포함하며, 파이썬의 일반적인 슬라이싱 규칙을 따릅니다.

3.  **조건부 선택: 불리언 인덱싱 (Boolean Indexing)**
    -   조건식을 대괄호 `[]` 안에 직접 넣는 것도 가능하지만, `loc`과 함께 사용하는 것이 더 명시적이고 권장됩니다.
    ```python
    # 'age'가 30 이상인 모든 행을 선택
    df.loc[df['age'] >= 30]
    
    # 'age'가 30 이상인 사람들의 'name'과 'salary' 열만 선택
    df.loc[df['age'] >= 30, ['name', 'salary']]
    ```

4.  **오개념 분석: `SettingWithCopyWarning` 경고의 이해**
    -   **상황**: `df[df['age'] > 30]['salary'] = 0` 와 같이 연쇄적으로 인덱싱하여 값을 변경하려고 할 때 `SettingWithCopyWarning`이라는 경고가 발생하며 값이 제대로 변경되지 않는 경우가 많습니다.
    -   **원인**: `df[df['age'] > 30]` 부분이 원본 데이터프레임을 직접 가리키는 '뷰(view)'를 반환할 수도 있고, 완전히 새로운 '복사본(copy)'을 반환할 수도 있습니다. 만약 복사본이 반환되었다면, 그 복사본의 'salary' 열을 수정하는 것은 원본 `df`에 아무런 영향을 주지 못합니다. Pandas는 이처럼 사용자의 의도가 불분명한 연쇄 할당을 경고하는 것입니다.
    -   **해결책**: 값을 변경할 때는 **항상 `loc`을 사용하여 단일 접근**으로 행과 열을 지정해야 합니다. 이는 Pandas에게 '원본을 직접 수정하겠다'는 의도를 명확히 전달하는 방법입니다.
    ```python
    # 올바른 방법: .loc[행 조건, 열 이름]
    df.loc[df['age'] > 30, 'salary'] = 0
    ```

#### 2. 깔끔한 Pandas 코드를 위한 메서드 체이닝 (Method Chaining)

메서드 체이닝은 여러 데이터 처리 단계를 중간 변수 없이 `.`으로 연결하여 파이프라인처럼 만드는 기법입니다.
-   **장점**:
    -   **가독성**: 데이터 처리 흐름이 위에서 아래로 순차적으로 나타나 코드를 읽고 이해하기 쉽습니다.
    -   **메모리 효율성**: 각 단계의 결과를 저장할 중간 변수를 만들지 않아 메모리 사용량을 줄일 수 있습니다.
    -   **디버깅**: 각 체인 단계별로 결과를 확인하며 디버깅하기 용이합니다.

-   **모범 사례**: 체인이 너무 길어지면 한 줄에 모두 작성하기보다, 소괄호 `()`로 전체 표현식을 묶고 각 메서드를 새로운 줄에 작성하는 것이 가독성에 좋습니다.
    ```python
    # 'age'가 30 이상인 데이터를 필터링하고,
    # 'salary' 기준으로 내림차순 정렬한 후,
    # 상위 5개의 'name'만 추출하는 예시
    top_5_names = (
        df.loc[df['age'] > 30]
             .sort_values(by='salary', ascending=False)
             .head(5)
             ['name']
    )
    ```

#### 3. 데이터 집계의 정수: `groupby`와 Split-Apply-Combine 전략

`groupby`는 데이터 분석에서 가장 강력하고 필수적인 기능 중 하나입니다. 특정 열의 값을 기준으로 데이터를 그룹으로 묶고, 각 그룹에 집계 함수를 적용하여 통찰력을 얻는 'Split-Apply-Combine' 전략을 구현합니다.

1.  **Split (분리)**: 지정된 열(예: '매장 지점')의 고유한 값들을 기준으로 데이터프레임을 여러 그룹으로 분리합니다.
2.  **Apply (적용)**: 각 그룹에 집계 함수(예: `sum()`, `mean()`, `count()`)를 적용합니다.
3.  **Combine (결합)**: 각 그룹별로 계산된 결과를 다시 하나의 데이터프레임으로 결합합니다.

-   **가상 시나리오**: "매장 지점별 평균 판매액과 최고 판매액 계산하기"
    -   **집계 (`agg`)**: 각 그룹을 하나의 요약된 값으로 변환합니다.
        ```python
        # 지점별 평균/최고 판매액 계산
        df.groupby('store')['sales'].agg(['mean', 'max'])
        ```
    -   **변환 (`transform`)**: 각 그룹별로 계산한 값을 원래 데이터프레임의 모든 행에 동일하게 적용합니다. 그룹 내 순위나 비율을 계산할 때 유용합니다.
        ```python
        # 각 판매액이 자신이 속한 지점의 평균 판매액 대비 얼마나 차이 나는지 계산
        store_mean = df.groupby('store')['sales'].transform('mean')
        df['sales_deviation'] = df['sales'] - store_mean
        ```
    -   **필터 (`filter`)**: 특정 조건을 만족하는 그룹 전체를 선택하거나 제외합니다.
        ```python
        # 평균 판매액이 1000 이상인 지점의 데이터만 필터링
        df.groupby('store').filter(lambda group: group['sales'].mean() >= 1000)
        ```

이처럼 `groupby`는 단순한 집계를 넘어, `transform`과 `filter`를 통해 그룹 단위의 복잡한 데이터 조작을 가능하게 하는 매우 강력한 기능입니다.

---

## 🌐 최신 동향 및 추가 정보

### 1. 더 빠른 연산을 위한 `eval()`과 `query()`
Pandas는 대규모 데이터셋에서 복잡한 연산을 수행할 때 성능을 높이기 위해 `eval()`과 `query()` 메서드를 제공합니다. 이들은 문자열 형태로 표현된 연산식을 C 기반의 `numexpr` 라이브러리를 통해 매우 빠르게 계산하여, 일반적인 파이썬 연산보다 메모리를 적게 사용하고 속도를 향상시킵니다.

```python
# 일반적인 방식
df[(df['A'] > df['B']) & (df['C'] < df['D'])]

# query()를 사용한 방식 (더 간결하고 빠름)
df.query('A > B and C < D')

# eval()을 사용한 열 생성
df.eval('E = (A + B) / C', inplace=True)
```

### 2. 메서드 체이닝의 확장: `.pipe()`
메서드 체이닝은 매우 유용하지만, 체인 중간에 `lambda` 함수가 아닌 일반 함수를 적용하기는 어렵습니다. `.pipe()` 메서드는 이러한 문제를 해결하여, 데이터프레임(또는 시리즈) 자체를 첫 번째 인자로 받는 함수를 체인 중간에 삽입할 수 있게 해줍니다. 이를 통해 코드의 가독성과 재사용성을 더욱 높일 수 있습니다.

```python
def calculate_ratio(df, col1, col2):
    """두 열의 비율을 계산하는 함수"""
    df_copy = df.copy()
    df_copy['ratio'] = df_copy[col1] / df_copy[col2]
    return df_copy

def remove_outliers(df, col):
    """이상치를 제거하는 함수"""
    q1 = df[col].quantile(0.25)
    q3 = df[col].quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    return df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]

# .pipe()를 사용하여 함수들을 체인으로 연결
processed_df = (df.pipe(calculate_ratio, 'A', 'B')
                  .pipe(remove_outliers, 'ratio')
               )
```

---

## 📚 핵심 용어집 (Glossary)

-   **Pandas**: 파이썬에서 테이블 형태의 데이터를 쉽게 다룰 수 있도록 강력한 자료구조(Series, DataFrame)와 분석 도구를 제공하는 핵심 데이터 분석 라이브러리.
-   **Series**: 값(values)과 인덱스(index)로 구성된 1차원 배열 형태의 Pandas 자료구조. DataFrame의 한 열(column)에 해당합니다.
-   **DataFrame**: 행(row)과 열(column)으로 구성된 2차원 테이블 형태의 Pandas 자료구조. 데이터 분석 작업의 중심이 됩니다.
-   **Index**: DataFrame의 행이나 Series의 값에 접근하기 위한 이름(label).
-   **NaN (Not a Number)**: Pandas에서 결측치(missing value)를 나타내는 표준 방식. `numpy.nan`에서 유래했습니다.
-   **`loc`**: 레이블(이름) 기반 인덱서. `df.loc['row_label', 'col_name']`과 같이 명시적인 이름으로 데이터에 접근합니다.
-   **`iloc`**: 정수 위치 기반 인덱서. `df.iloc[0, 1]`과 같이 0부터 시작하는 정수 위치로 데이터에 접근합니다.
-   **메서드 체이닝 (Method Chaining)**: 여러 개의 메서드를 `.`으로 연결하여, 중간 변수 생성 없이 데이터 처리 파이프라인을 구성하는 코딩 스타일.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. Pandas의 `axis` 매개변수 완전 정복
AI가 "axis=0과 axis=1의 차이가 뭔가요?"라는 단골 질문에 명확한 비유로 답변할 수 있도록 돕는 자료입니다.
-   **핵심**: `axis`는 연산이 적용될 **방향**을 지정합니다.
    -   `axis=0` (또는 `axis='index'`) : **행(row) 방향**으로 연산을 수행합니다. 여러 행들이 하나의 결과로 압축되는 이미지를 떠올리면 쉽습니다. (↓ 방향)
    -   `axis=1` (또는 `axis='columns'`) : **열(column) 방향**으로 연산을 수행합니다. 여러 열들이 하나의 결과로 압축되는 이미지를 떠올리면 쉽습니다. (→ 방향)
-   **시나리오**: 학생들의 과목별 점수가 담긴 DataFrame이 있을 때.
    -   **과목별 평균 점수 계산**: 각 열(과목)에 있는 모든 학생의 점수를 합산하여 평균을 내야 합니다. 즉, **행 방향(↓)**으로 데이터가 압축됩니다. → `df.mean(axis=0)`
    -   **학생별 총점 계산**: 각 행(학생)에 있는 모든 과목의 점수를 합산해야 합니다. 즉, **열 방향(→)**으로 데이터가 압축됩니다. → `df.sum(axis=1)`
-   **AI 답변 가이드**: 사용자가 `axis`를 질문하면, "0은 세로, 1은 가로"와 같은 단순한 설명 대신, 위와 같이 '연산이 진행되는 방향'과 '데이터가 압축되는 방향'이라는 개념을 학생/과목 예시와 함께 설명하도록 유도합니다.

### 2. Pandas의 마법: 브로드캐스팅 (Broadcasting)
AI가 "모양이 다른데 어떻게 연산이 되나요?"라는 질문에 Numpy에서 유래한 브로드캐스팅 개념으로 답변할 수 있도록 돕는 자료입니다.
-   **핵심**: 브로드캐스팅은 Pandas(내부적으로 Numpy)가 모양(shape)이 다른 배열/Series 간의 연산을 수행할 때, 더 작은 쪽을 **자동으로 확장**하여 모양을 맞춘 후 연산을 수행하는 규칙입니다.
-   **시나리오**: 모든 학생의 수학 점수에서 수학 과목의 평균 점수를 한 번에 빼고 싶을 때.
    ```python
    # df: (100, 5) 모양의 전체 학생 점수 DataFrame
    # math_mean: 수학 점수 평균 (하나의 스칼라 값)
    df['math_deviation'] = df['math'] - math_mean
    ```
-   **동작 원리**: 위 코드에서 스칼라 값 `math_mean`은 `df['math']` Series의 모든 원소(100개)에 적용될 수 있도록 **100번 복제(확장)**되어 연산이 수행됩니다. 이것이 브로드캐스팅의 가장 간단한 예입니다.
-   **AI 답변 가이드**: 사용자가 모양이 다른 객체 간의 연산을 질문하면, "Pandas가 똑똑해서 알아서 해줘요"가 아니라, "Numpy의 브로드캐스팅 규칙에 따라, 더 작은 배열/스칼라가 더 큰 배열의 모양에 맞게 가상으로 확장된 후, 요소별(element-wise) 연산이 수행됩니다"라고 근본 원리를 설명하도록 유도합니다.

---

## 📚 참고 자료 (References)

-   Pandas User Guide: Pandas의 모든 기능을 다루는 공식 사용자 가이드
-   10 minutes to pandas: Pandas의 핵심 기능을 빠르게 익힐 수 있는 공식 입문서
-   Python for Data Analysis, 3E: Pandas 창시자 Wes McKinney가 집필한 데이터 분석 필독서
-   Modern Pandas (by Tom Augspurger): 효율적이고 현대적인 Pandas 코드 작성법을 다루는 튜토리얼
# 10강. 7장 파이썬과 R 시각화

## 학습 목표
1. 파이썬 `matplotlib` 패키지를 이용하여 그래프를 그리는 방법을 알 수 있다.
2. 파이썬 `seaborn` 패키지를 이용하여 그래프를 그리는 방법을 알 수 있다.
3. R의 `ggplot2` 패키지를 이용하여 그래프를 그리는 방법을 알 수 있다.

---

## 📝 요약 (Summary)
1.  **시각화 라이브러리의 역할**: 데이터 시각화는 숫자만으로는 파악하기 어려운 데이터의 패턴, 관계, 이상치 등을 직관적으로 이해할 수 있도록 돕는 필수적인 분석 과정입니다. 파이썬과 R은 각각 강력한 시각화 생태계를 가지고 있습니다.
2.  **파이썬 시각화 생태계 (`matplotlib`과 `seaborn`)**:
    -   **`matplotlib`**: 파이썬 시각화의 근간이 되는 라이브러리로, 저수준(low-level)의 세밀한 제어 기능을 제공하여 거의 모든 종류의 그래프를 맞춤 제작할 수 있습니다. 유연성이 높은 만큼 코드가 다소 복잡해질 수 있습니다.
    -   **`seaborn`**: `matplotlib`을 기반으로 만들어진 고수준(high-level) 라이브러리입니다. 통계적 데이터 시각화에 특화되어 있으며, Pandas DataFrame과 완벽하게 호환되어 더 적은 코드로도 미려하고 정보량이 풍부한 그래프를 쉽게 그릴 수 있습니다.
3.  **R 시각화의 표준 (`ggplot2`)**: R의 `ggplot2`는 '그래픽의 문법(Grammar of Graphics)'이라는 독자적인 철학을 기반으로 합니다. 데이터를 미적 요소(색상, 모양, 크기 등)에 매핑하고, 이를 기하학적 객체(점, 선, 막대 등)로 표현하는 레이어를 순차적으로 쌓아 그래프를 완성합니다. 일관성 있는 문법 덕분에 복잡한 그래프도 논리적으로 쉽게 구현할 수 있습니다.

---

## ✏️ 심화 학습 (Study Subject)
### 1. 시각화 도구의 철학 비교: Matplotlib vs. Seaborn vs. ggplot2

세 라이브러리는 단순히 그래프를 그리는 도구가 아니라, 데이터를 바라보는 서로 다른 철학을 담고 있습니다.

#### 가. 관점별 비교

| 관점 | `matplotlib` (화가) | `seaborn` (큐레이터) | `ggplot2` (건축가) |
| :--- | :--- | :--- | :--- |
| **핵심 철학** | **"무엇이든 그릴 수 있다"**: 빈 캔버스에 점, 선, 텍스트 등 모든 요소를 직접 배치하는 방식. | **"아름답고 정보가 풍부하게"**: 통계적 관계를 잘 보여주는 미려한 그래프를 최소한의 코드로 제공. | **"문법에 따라 체계적으로"**: 데이터, 미적 매핑, 기하학적 객체 등 구성 요소를 레이어처럼 쌓아 올리는 방식. |
| **코드 스타일** | 절차적(Imperative): "x축을 그리고, y축을 그리고, 점을 찍어라" | 선언적(Declarative): "x와 y 데이터로 산점도를 그려줘" | 선언적(Declarative): "x와 y를 위치에, 종을 색상에 매핑하여 점으로 표현해줘" |
| **데이터 구조** | Numpy 배열과 같은 저수준 자료구조에 친화적 | **Pandas DataFrame**에 최적화 | **Tidy Data** 형태의 `data.frame` 또는 `tibble`에 최적화 |
| **장점** | 최고의 유연성, 모든 요소를 완벽하게 제어 가능 | 간결한 코드, 뛰어난 심미성, 통계 기능 내장 | 논리적 일관성, 코드 재사용성, 복잡한 그래프의 체계적 구현 |
| **단점** | 코드가 길고 복잡해지기 쉬움, 기본 디자인이 미려하지 않음 | `matplotlib`에 비해 커스터마이징 유연성이 다소 낮음 | 초기 학습 곡선이 존재함, `+` 기호로 레이어를 연결하는 독특한 문법 |

#### 나. 가상 시나리오: "iris 데이터셋으로 품종별 꽃받침 길이와 너비의 관계 시각화하기"

-   **`matplotlib` 접근법**: 품종별로 데이터를 직접 필터링하고, 각 품종에 맞는 색상을 지정하여 여러 번의 `plot` 명령을 실행해야 합니다.
    ```python
    import matplotlib.pyplot as plt
    from sklearn.datasets import load_iris
    iris = load_iris()
    # ... 데이터 전처리 ...
    
    # 각 품종별로 색상을 지정하여 반복문으로 그리기
    for i, species_name in enumerate(iris.target_names):
        species_data = X[y == i]
        plt.scatter(species_data[:, 0], species_data[:, 1], label=species_name)
    plt.legend()
    plt.xlabel('Sepal Length')
    plt.ylabel('Sepal Width')
    plt.show()
    ```

-   **`seaborn` 접근법**: `hue` 인자에 품종 열을 지정하기만 하면, 자동으로 데이터를 그룹화하고 색상을 할당하여 범례까지 그려줍니다.
    ```python
    import seaborn as sns
    import pandas as pd
    # ... 데이터를 Pandas DataFrame으로 변환 ...
    
    sns.scatterplot(data=iris_df, x='sepal_length', y='sepal_width', hue='species')
    plt.show()
    ```

-   **`ggplot2` 접근법**: `aes()`(미적 매핑) 안에 x, y, color를 정의하고, `geom_point()`(기하학적 객체) 레이어를 `+`로 추가합니다.
    ```R
    library(ggplot2)
    
    ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
      geom_point()
    ```

### 2. 오개념 분석: "Seaborn은 Matplotlib을 대체하는 라이브러리인가?"

-   **분석**: **아닙니다.** Seaborn은 Matplotlib을 대체하는 것이 아니라, **보완하고 확장하는** 관계입니다. Seaborn으로 그린 모든 그래프는 내부적으로 Matplotlib 객체(Figure, Axes)로 구성됩니다. 따라서 Seaborn으로 고수준의 그래프를 빠르고 예쁘게 그린 다음, 제목 추가, 축 레이블 변경, 폰트 크기 조절 등 세부적인 커스터마이징이 필요할 때는 Matplotlib의 함수(`plt.title()`, `ax.set_xlabel()`)를 그대로 가져와 사용할 수 있습니다. 이 둘의 관계를 이해하면, 생산성과 유연성 두 마리 토끼를 모두 잡을 수 있습니다.


---

## ❓ 연습 문제 및 해설

### 📝 문제

**1. [파이썬에서 외부에 별도의 창을 띄워서 그래프를 그리고자 한다. ( ) 안의 명령은?](#prob-1)**
```python
import numpy as np
import matplotlib.pyplot as plt

%matplotlib ( )

x = np.random.randn(100)
y = np.random.randn(100)

plt.plot(y, 'b:')
plt.title('Green Solid Line')
plt.title('Blue Dotted Line')
```




<br>

**2. [다음과 같이 y = x, y = x^2, y = x^3의 그래프를 그렸다. 왼쪽 상단에 범례를 그리기 위한 명령 (        )은? ?](#prob-2)**
```python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 2, 100)
plt.figure()

plt.plot(x,   x,     label='linear')
plt.plot(x,   x**2,  label='quadratic')
plt.plot(x,   x**3,  label='cubic')

(        )

plt.grid(True)
plt.text(1.6, 7,   r'$y=x^3$')
plt.text(1.9, 4.5, r'$y=x^2$')
plt.text(1.9, 1.4, r'$y=x$')
plt.title("Simple Polynomials : 2")

```

<br>

**3. [그림과 같이 y = f(x) 의 그래프를 네 개로 분할하여 그리고자 한다. (       ) 명령은?](#prob-3)**
```python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 1, 200)
y = np.sqrt(x)

fig, axs = (              )

axs[0, 0].plot(x, y)
axs[0, 1].plot(x, -y)
axs[1, 0].plot(x, y)
axs[1, 1].plot(x, -y)
```

<br>

**4. [그림과 같이 seaborn 패키지를 이용하여 그래프를 그렸다. (       ) 함수는?](#prob-4)**
```python
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style="darkgrid")
iris = sns.load_dataset("iris")
iris.columns = ['sl', 'sw', 'pl', 'pw', 'sp']
(        )(x='sw', y='sl', hue='sp', data=iris)

```

<br>

**5. [R의 ggplot2 패키지를 이용하여 다음과 같은 그래프를 그렸다. (        ) 옵션은?](#prob-5)**
```R
library(ggplot2)

head(trees)

trees[c(1:2, 30:31), ]

H = cut(trees$Height, 4)

ggplot(data = trees) +
  (   )aes(x = Girth, y = Volume) +
  (   )aes(x = Girth, y = Volume, col = H) +

```

<br>




---

### 🔑 정답

1. qt5
2. plt.legend()
3. plt.subplots(2,2)
4. sns.lmplot
5. geom_point

---

### 🧐 해설

<a id="prob-1"></a>

**1. 파이썬에서 외부에 별도의 창을 띄워서 그래프를 그리고자 한다. ( ) 안의 명령은?**
> **정답**: `qt5`
> **해설**: Jupyter Notebook이나 Spyder 환경에서 Matplotlib 그래프를 표시하는 방식을 '백엔드(backend)'라고 합니다. `%matplotlib` 매직 명령어는 이 백엔드를 설정합니다.
> **`%matplotlib inline`**: (기본값) 그래프를 코드 셀 바로 아래에 이미지 형태로 삽입합니다. 정적이며 상호작용이 불가능합니다.
> **`%matplotlib qt5`** 또는 **`%matplotlib tk`**: 그래프를 별도의 독립된 창(GUI 윈도우)으로 띄웁니다. 확대, 축소, 저장 등 상호작용이 가능하여 데이터를 자세히 탐색할 때 유용합니다.

<a id="prob-2"></a>

**2. 아래 <보기> 중 데이터과학의 특징으로 옳은 것은 모두 몇 개인가?**
> **정답: ④ 4개**
> **해설**: <보기> 의 내용에서 선택

**2. 각 선의 의미를 설명하는 범례를 표시하기 위한 명령 ( )은?**
> **정답**: `plt.legend()`
> **해설**: `plt.legend()` 함수는 `plot` 함수에서 `label` 인자로 지정된 이름들을 모아 범례(legend)를 생성합니다. 범례의 위치는 `loc` 인자를 통해 조절할 수 있습니다. (예: `plt.legend(loc='upper left')`)

<a id="prob-3"></a>

**3. 문제?**
> **정답: ③ 내용(body)**
> **해설**: 해설 **핵심내용(keyword)**,

**3. 하나의 그림(Figure) 안에 2x2 격자 형태로 4개의 하위 그래프(Axes)를 만들고자 한다. ( )에 들어갈 명령은?**
> **정답**: `plt.subplots(2, 2)`
> **해설**: `plt.subplots()` 함수는 하나의 그림(Figure) 안에 여러 개의 하위 그래프(Axes)를 격자 형태로 생성하는 가장 일반적인 방법입니다.
> - `plt.subplots(nrows, ncols)`: `nrows`개의 행과 `ncols`개의 열로 구성된 격자를 만듭니다.
> - 이 함수는 전체 그림을 나타내는 `fig` 객체와, 각 하위 그래프를 담고 있는 2차원 배열 `axs`를 반환합니다. `axs[0, 0]`는 첫 번째 행, 첫 번째 열의 그래프를 의미합니다.

<a id="prob-4"></a>

**4. seaborn 패키지를 이용하여 산점도와 선형 회귀선을 그리고자 한다. ( )에 들어갈 함수는?**
> **정답**: `sns.lmplot`
> **해설**: Seaborn의 `lmplot()` 함수는 산점도(scatter plot)와 선형 회귀선(linear regression model plot)을 함께 그려주는 강력한 함수입니다. `hue` 인자를 사용하면 지정된 범주형 변수에 따라 데이터를 그룹화하고, 그룹별로 다른 색상의 산점도와 회귀선을 그려주어 데이터의 관계를 다각적으로 분석할 수 있습니다.

<a id="prob-5"></a>

**5. R의 ggplot2 패키지를 이용하여 산점도를 그리고자 한다. ( )에 들어갈 기하 객체(geom) 함수는?**
> **정답**: `geom_point()`
> **해설**: `ggplot2`는 '그래픽의 문법'에 따라 레이어를 쌓아 그래프를 완성합니다.
> `ggplot(data = ...)`: 사용할 데이터셋을 지정합니다.
> `aes(x = ..., y = ...)`: 데이터의 어떤 변수를 x축, y축, 색상(col) 등 미적 요소(aesthetic)에 매핑할지 정의합니다.
> `geom_...()`: 데이터를 실제로 어떤 기하학적 객체(geometric object)로 표현할지 결정합니다. `geom_point()`는 점(point)으로, 즉 산점도로 표현하라는 의미입니다. 이 부분을 `geom_line()`으로 바꾸면 꺾은선 그래프가, `geom_bar()`로 바꾸면 막대그래프가 됩니다.


---

## ✅ O/X 확인문제
**1.** [Matplotlib에서 `plt.plot()` 함수에 `label` 인자를 지정하면 자동으로 범례가 표시된다.](#ox-1) **(O / X)**
**2.** Seaborn은 Matplotlib과 완전히 독립적인 라이브러리로, 함께 사용할 수 없다. **(O / X)**
**3.** R의 `ggplot2`에서 `+` 기호는 그래프 레이어를 추가하는 역할을 한다. **(O / X)**
**4.** Matplotlib의 `plt.subplots(3, 1)`는 3개의 행과 1개의 열로 구성된 하위 그래프들을 생성한다. **(O / X)**
**5.** Seaborn의 `lmplot`은 산점도만 그리는 함수이다. **(O / X)**
**6.** `ggplot2`에서 `aes()` 함수는 그래프의 색상, 모양, 크기 등 미적 요소를 데이터에 매핑하는 역할을 한다. **(O / X)**
**7.** Jupyter Notebook에서 `%matplotlib inline`을 사용하면 그래프를 별도의 창으로 띄울 수 있다. **(O / X)**
**8.** Matplotlib에서 `plt.title()`은 그래프의 x축 제목을 설정하는 함수이다. **(O / X)**
**9.** `ggplot2`에서 데이터를 점으로 표현하고 싶을 때는 `geom_scatter()` 함수를 사용한다. **(O / X)**
**10.** Seaborn은 Pandas DataFrame 형식의 데이터를 입력받을 때 가장 편리하게 사용할 수 있다. **(O / X)**


> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: `label` 인자는 범례에 표시될 텍스트를 지정할 뿐, 실제로 범례를 화면에 그리려면 반드시 `plt.legend()` 함수를 호출해야 합니다.

> <a id="ox-2"></a>
> **2. 정답**: X
> **해설**: Seaborn은 Matplotlib을 기반으로 만들어진 라이브러리입니다. 따라서 Seaborn으로 그린 그래프 객체에 Matplotlib 함수를 사용하여 세부적인 요소를 추가하거나 수정할 수 있습니다.

> <a id="ox-3"></a>
> **3. 정답**: O
> **해설**: `ggplot2`는 데이터, 미적 매핑, 기하 객체, 통계 변환 등 각 요소를 레이어로 간주하고, `+` 기호를 사용하여 이들을 순차적으로 쌓아 그래프를 완성합니다.

> <a id="ox-4"></a>
> **4. 정답**: O
> **해설**: `plt.subplots(nrows, ncols)` 함수는 `nrows`개의 행과 `ncols`개의 열로 구성된 하위 그래프 격자를 생성합니다.

> <a id="ox-5"></a>
> **5. 정답**: X
> **해설**: `lmplot`은 산점도와 함께 데이터의 추세를 보여주는 선형 회귀선을 함께 그려주는 것이 핵심 기능입니다.

> <a id="ox-6"></a>
> **6. 정답**: O
> **해설**: `aes()`는 'aesthetics(미학)'의 약자로, 데이터의 변수를 시각적 속성(위치, 색, 모양, 크기 등)에 어떻게 연결할지 정의하는 `ggplot2`의 핵심 요소입니다.

> <a id="ox-7"></a>
> **7. 정답**: X
> **해설**: `%matplotlib inline`은 그래프를 코드 셀 바로 아래에 삽입하는 방식입니다. 별도의 창으로 띄우려면 `%matplotlib qt5` 등을 사용해야 합니다.

> <a id="ox-8"></a>
> **8. 정답**: X
> **해설**: `plt.title()`은 그래프의 전체 제목을, `plt.xlabel()`과 `plt.ylabel()`이 각각 x축과 y축의 제목을 설정하는 함수입니다.

> <a id="ox-9"></a>
> **9. 정답**: X
> **해설**: `ggplot2`에서 점(산점도)을 그리는 기하 객체는 `geom_point()`입니다.

> <a id="ox-10"></a>
> **10. 정답**: O
> **해설**: Seaborn은 통계 데이터 시각화에 특화되어 있으며, Pandas DataFrame의 열 이름을 `x`, `y`, `hue` 등의 인자로 바로 전달하여 매우 간결하게 그래프를 그릴 수 있도록 설계되었습니다.

---


## 📖 심화 학습 예시 답안

#### 1. Matplotlib의 두 가지 인터페이스: `pyplot` vs. 객체 지향 API

Matplotlib에는 그래프를 그리는 두 가지 주요 방식이 있으며, 상황에 따라 적절한 방식을 선택하는 것이 중요합니다.

1.  **`pyplot` 상태 기반 인터페이스 (State-based Interface)**:
    -   **설명**: `plt.plot()`, `plt.title()`처럼 `plt`라는 '현재 상태'에 순차적으로 명령을 내려 그래프를 그리는 방식입니다. MATLAB과 유사하며, 간단한 그래프를 빠르게 그릴 때 매우 편리하고 직관적입니다.
    -   **예시**:
        ```python
        import matplotlib.pyplot as plt
        x = [1, 2, 3]
        y = [2, 4, 1]
        plt.figure()
        plt.plot(x, y)
        plt.title("My Simple Plot")
        plt.show()
        ```

2.  **객체 지향 인터페이스 (Object-Oriented API)**:
    -   **설명**: `fig, ax = plt.subplots()`처럼 `Figure`(그림 전체)와 `Axes`(개별 그래프) 객체를 명시적으로 생성하고, 각 객체의 메서드(`ax.plot()`, `ax.set_title()`)를 호출하여 그래프를 구성하는 방식입니다. 코드가 조금 더 길어지지만, 여러 개의 하위 그래프를 그리거나 복잡한 그래프의 각 요소를 세밀하게 제어해야 할 때 훨씬 더 강력하고 유연합니다.
    -   **예시**:
        ```python
        import matplotlib.pyplot as plt
        x = [1, 2, 3]
        y = [2, 4, 1]
        fig, ax = plt.subplots()
        ax.plot(x, y)
        ax.set_title("My Object-Oriented Plot")
        plt.show()
        ```

**결론**: 간단한 시각화는 `pyplot` 방식으로 충분하지만, 재사용 가능한 함수를 만들거나 여러 그래프를 동시에 다루는 등 복잡한 작업을 할 때는 **객체 지향 API**를 사용하는 것이 더 좋은 프로그래밍 습관입니다. Seaborn 함수들도 내부적으로는 이 객체 지향 API를 사용하며, Seaborn으로 그린 그래프의 세부 조정을 위해 Matplotlib의 `Axes` 객체 메서드를 활용하는 경우가 많습니다.

#### 2. `ggplot2`의 핵심 철학: 그래픽의 문법 (Grammar of Graphics)

`ggplot2`의 강력함은 '그래픽의 문법'이라는 일관된 철학에서 나옵니다. 이는 그래프를 다음과 같은 독립적인 구성 요소(레이어)의 조합으로 보는 것입니다.

| 요소 | 역할 | `ggplot2` 함수 |
| :--- | :--- | :--- |
| **Data (데이터)** | 시각화할 실제 데이터. (Tidy 형태의 데이터프레임) | `ggplot(data = ...)` |
| **Aesthetics (미학)** | 데이터의 변수를 시각적 속성(x/y 위치, 색, 모양, 크기)에 매핑. | `aes(x = ..., y = ..., color = ...)` |
| **Geometries (기하)** | 데이터를 화면에 표현할 기하학적 객체. (점, 선, 막대 등) | `geom_point()`, `geom_line()`, `geom_bar()` |
| **Facets (분할)** | 데이터의 하위 그룹별로 여러 개의 패널에 그래프를 그림. | `facet_wrap(~ variable)` |
| **Statistics (통계)** | 데이터에 통계적 변환을 적용. (빈도수 세기, 평균 계산 등) | `stat_summary()`, `stat_smooth()` |
| **Coordinates (좌표)** | x/y 좌표계를 설정. (데카르트, 극좌표 등) | `coord_cartesian()`, `coord_flip()` |
| **Theme (테마)** | 그래프의 비(非)데이터 요소(배경, 글꼴, 범례 등)를 꾸밈. | `theme_bw()`, `theme(...)` |

이러한 문법을 이해하면, `+` 기호로 필요한 요소를 레고 블록처럼 조립하여 매우 복잡한 그래프도 논리적이고 체계적으로 만들 수 있습니다. 예를 들어, 산점도(`geom_point`)에 추세선(`geom_smooth`) 레이어를 추가하는 것은 단순히 `+ geom_smooth()` 한 줄을 더하는 것만으로 가능합니다.


---

## 🌐 최신 동향 및 추가 정보

### 1. 파이썬 시각화의 새로운 강자: Plotly와 Altair

-   **Plotly**: Matplotlib/Seaborn이 정적인 이미지 생성에 강점이 있다면, Plotly는 **인터랙티브(interactive) 웹 기반 시각화**에 특화된 라이브러리입니다. 마우스를 올리면 정보가 나타나고, 특정 부분을 확대/축소하며, 범례를 클릭하여 데이터를 필터링하는 등의 동적인 그래프를 쉽게 만들 수 있습니다. 대시보드 제작이나 웹 애플리케이션에 시각화를 삽입할 때 매우 강력합니다.

-   **Altair**: R의 `ggplot2`처럼 '그래픽의 문법'에 기반한 선언적(declarative) 시각화 라이브러리입니다. JSON 기반의 Vega-Lite 명세를 사용하므로, 코드가 매우 간결하고 직관적입니다. 데이터 변환과 시각화를 유기적으로 결합하여 복잡한 통계 시각화를 논리적으로 표현하는 데 강점이 있습니다.

### 2. R 시각화 생태계의 확장

`ggplot2`는 R 시각화의 중심이지만, 이를 더욱 확장하는 다양한 패키지들이 존재합니다.
-   **`gganimate`**: `ggplot2`로 만든 정적 그래프에 시간의 흐름에 따른 변화를 추가하여 동적인 애니메이션으로 만들어 줍니다.
-   **`ggiraph`**: `ggplot2` 그래프를 Plotly처럼 인터랙티브하게 만들어 줍니다.
-   **`patchwork`**: 여러 개의 `ggplot2` 그래프를 매우 쉽고 직관적으로 조합하여 하나의 그림으로 배치할 수 있게 해주는 패키지입니다.

---

## 📚 핵심 용어집 (Glossary)

-   **`matplotlib`**: 파이썬의 가장 기본적이고 강력한 시각화 라이브러리. 저수준 제어를 통해 거의 모든 종류의 그래프를 만들 수 있습니다.
-   **`seaborn`**: `matplotlib`을 기반으로 만들어진 통계 데이터 시각화 라이브러리. 더 적은 코드로 미려하고 정보량이 풍부한 그래프를 그릴 수 있습니다.
-   **`ggplot2`**: R의 대표적인 시각화 패키지. '그래픽의 문법'이라는 독자적인 철학을 기반으로 레이어를 쌓아 그래프를 만듭니다.
-   **Figure**: Matplotlib에서 그래프가 그려지는 전체 캔버스 또는 창. 하나의 Figure는 여러 개의 Axes를 포함할 수 있습니다.
-   **Axes**: Figure 내부에 있는 개별 그래프 영역. 실제 플롯(plot)이 그려지는 공간입니다.
-   **Aesthetics (미학, `aes`)**: `ggplot2`의 용어로, 데이터의 변수(열)를 그래프의 시각적 속성(x/y 위치, 색, 모양, 크기 등)에 매핑하는 규칙.
-   **Geometries (기하 객체, `geom`)**: `ggplot2`의 용어로, 데이터를 화면에 표현하는 실제 모양. 점(`geom_point`), 선(`geom_line`), 막대(`geom_bar`) 등이 있습니다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. 시각화 목적에 따른 그래프 선택 가이드
AI가 "어떤 그래프를 그려야 할지 모르겠어요"라는 질문에 적절한 그래프 유형을 추천할 수 있도록 돕는 자료입니다.
-   **분포 (Distribution)**: 하나의 연속형 변수의 분포를 확인할 때
    -   `히스토그램 (Histogram)`: `plt.hist()`, `sns.histplot()`, `geom_histogram()`
    -   `커널 밀도 추정 그래프 (KDE Plot)`: `sns.kdeplot()`, `geom_density()`
-   **관계 (Relationship)**: 두 연속형 변수 간의 관계를 확인할 때
    -   `산점도 (Scatter Plot)`: `plt.scatter()`, `sns.scatterplot()`, `geom_point()`
-   **비교 (Comparison)**: 여러 범주 간의 값을 비교할 때
    -   `막대 그래프 (Bar Plot)`: `plt.bar()`, `sns.barplot()`, `geom_bar()` 또는 `geom_col()`
    -   `상자 그림 (Box Plot)`: `plt.boxplot()`, `sns.boxplot()`, `geom_boxplot()`
-   **시간에 따른 변화 (Change over Time)**: 시간의 흐름에 따른 데이터 변화를 확인할 때
    -   `꺾은선 그래프 (Line Plot)`: `plt.plot()`, `sns.lineplot()`, `geom_line()`

### 2. "Tidy Data" 원칙과 시각화의 관계
AI가 `seaborn`이나 `ggplot2` 사용 시 데이터 형식의 중요성을 설명할 수 있도록 돕는 자료입니다.
-   **Tidy Data란?**: 데이터 분석에 적합한 '깔끔한' 데이터 형태로, 다음 세 가지 원칙을 따릅니다.
    1.  각 변수(variable)는 하나의 열(column)을 구성한다.
    2.  각 관측치(observation)는 하나의 행(row)을 구성한다.
    3.  각 값(value)은 하나의 셀(cell)을 구성한다.
-   **중요성**: `seaborn`과 `ggplot2`는 Tidy Data 형식에 최적화되어 있습니다. 데이터가 Tidy 형태일 때, `x='연도'`, `y='판매량'`, `hue='제품군'`과 같이 열 이름을 각 인자에 직접 매핑하여 매우 쉽고 직관적으로 복잡한 그래프를 그릴 수 있습니다. 데이터가 'Wide' 형태(예: 열 이름이 '2021년 판매량', '2022년 판매량'인 경우)라면, 먼저 `melt`(Pandas)나 `pivot_longer`(tidyr) 함수를 사용해 Tidy 형태로 변환해야 이들 라이브러리의 진정한 힘을 발휘할 수 있습니다.

---

## 📚 참고 자료 (References)

- Matplotlib 공식 튜토리얼
- Seaborn 공식 튜토리얼
- R for Data Science - Data visualisation
- From Data to Viz: 데이터 유형에 맞는 그래프를 추천해주는 웹사이트
# 05. R 데이터 편집

## 학습 목표
1. R의 개념을 설명하고 설치할 수 있다.
2. R의 기본 데이터 구조(벡터, 행렬, 리스트, 데이터프레임)의 특징을 설명할 수 있다.
3. `tidyverse`의 개념과 핵심 철학을 이해한다.
4. `tibble`이 기존 데이터프레임과 어떻게 다른지 설명할 수 있다.
5. `dplyr` 패키지의 핵심 함수(`select`, `filter`, `arrange`, `mutate`, `summarise`, `group_by`)를 사용하여 데이터를 편집할 수 있다.

---

## 📝 요약 (Summary)
1.  **R과 RStudio**: R은 통계 분석과 그래픽을 위한 프로그래밍 언어이며, RStudio는 R을 더 편리하게 사용할 수 있도록 돕는 통합 개발 환경(IDE)입니다.
2.  **R의 기본 데이터 구조**: R은 데이터를 담는 다양한 그릇을 제공합니다. **벡터**(1차원, 동일 타입), **행렬**(2차원, 동일 타입), **배열**(다차원, 동일 타입), **리스트**(여러 데이터 구조의 조합), **데이터프레임**(2차원, 다른 타입 허용)이 대표적입니다.
3.  **Tidyverse**: 데이터 과학 작업을 더 쉽고, 빠르고, 재미있게 만들기 위한 R 패키지들의 모음입니다. 일관된 문법과 데이터 구조를 공유하여 코드 가독성과 생산성을 높입니다.
4.  **Tibble**: `tidyverse` 생태계의 표준 데이터프레임입니다. 기존 데이터프레임의 불편한 점(예: 자동 형 변환)을 개선하여 더 엄격하고 예측 가능한 동작을 보장합니다.
5.  **dplyr**: `tidyverse`의 핵심 패키지로, 데이터 조작을 위한 강력하고 직관적인 동사(함수)들을 제공합니다. `select()`, `filter()`, `arrange()`, `mutate()` 등의 함수를 조합하여 복잡한 데이터 편집 작업을 손쉽게 수행할 수 있습니다.

---

## ✏️ 심화 학습 (Study Subject)
1.  R의 기본 데이터 구조 5가지(벡터, 행렬, 배열, 리스트, 데이터프레임)의 특징을 비교하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예를 들어 설명하시오.
2.  `tidyverse`의 핵심 철학인 'Tidy Data(깔끔한 데이터)'의 세 가지 원칙을 설명하고, 왜 이 원칙이 데이터 분석에서 중요한지 설명하시오.
3.  `dplyr` 패키지의 핵심 함수 6가지(`select`, `filter`, `arrange`, `mutate`, `summarise`, `group_by`)의 기능을 각각 설명하고, 이 함수들을 조합하여 '특정 조건을 만족하는 데이터를 추출하고, 원하는 순서로 정렬한 뒤, 새로운 파생변수를 추가하는' 가상 시나리오를 코드로 작성하시오.

---

## ❓ 연습 문제 및 해설

### 📝 문제

**1. [다음 중 벡터(Vector)를 생성하는 R 함수가 아닌 것은?](#prob-1)**
   > ① `c()`
   > ② `seq()`
   > ③ `rep()`
   > ④ `sd()`

<br>

**2.[`matrix(1:6, ncol=2, nrow=3)` 코드의 실행 결과로 생성되는 행렬의 차원은?](#prob-2)**
   > ① 2행 3열
   > ② 3행 2열
   > ③ 1행 6열
   > ④ 6행 1열

<br>

**3. [R의 데이터 구조에 대한 설명으로 가장 옳지 않은 것은?](#prob-3)**
   > ① 벡터(Vector)는 동일한 데이터 타입의 원소들로만 구성된다.
   > ② 행렬(Matrix)은 2차원 구조이며, 모든 원소는 동일한 데이터 타입이어야 한다.
   > ③ 데이터프레임(Data Frame)은 서로 다른 데이터 타입의 열(column)을 가질 수 있다.
   > ④ 리스트(List)는 숫자형 데이터와 문자형 데이터를 함께 저장할 수 없다.

<br>

**4. [다음 중 `tidyverse` 생태계에 포함된 패키지와 그 주된 용도가 올바르게 짝지어진 것은?](#prob-4)**
   > ① `ggplot2`: 데이터 조작
   > ② `dplyr`: 데이터 시각화
   > ③ `readr`: 데이터 불러오기
   > ④ `tibble`: 문자열 처리

<br>

**5. [다음 `dplyr` 패키지의 함수 중, 데이터의 행(관측치)을 특정 조건에 따라 추출하는 기능을 수행하는 것은?](#prob-5)**
   > ① `select()`
   > ② `arrange()`
   > ③ `filter()`
   > ④ `mutate()`

<br>

**6. [기존 `data.frame`을 `tibble`로 변환할 때 사용하는 함수로 가장 적절한 것은?](#prob-6)**
   > ① `as.data.frame()`
   > ② `as_tibble()`
   > ③ `read_csv()`
   > ④ `tibble()`


---

### 🔑 정답
1. ④
2. ②
3. ④
4. ③
5. ③
6. ②

---

### 🧐 해설

<a id="prob-1"></a>
**1. 다음 중 벡터(Vector)를 생성하는 R 함수가 아닌 것은?**
> **정답: ④ sd()**
> **해설**: `sd()` 함수는 벡터의 표준편차(Standard Deviation)를 계산하는 함수입니다.
> - ① `c()`: 여러 원소를 결합하여 벡터를 생성하는 가장 기본적인 함수입니다. (예: `c(1, 2, 3)`)
> - ② `seq()`: 연속된 수열을 생성합니다. (예: `seq(from=1, to=10, by=2)`)
> - ③ `rep()`: 특정 값을 반복하여 벡터를 생성합니다. (예: `rep(0, 5)`)

<a id="prob-2"></a>
**2. `matrix(1:6, ncol=2, nrow=3)` 코드의 실행 결과로 생성되는 행렬의 차원은?**
> **정답: ② 3행 2열**
> **해설**: `matrix()` 함수에서 `nrow`는 행(row)의 개수, `ncol`은 열(column)의 개수를 지정합니다. 따라서 `nrow=3`, `ncol=2`는 3행 2열의 행렬을 생성합니다.

<a id="prob-3"></a>
**3. R의 데이터 구조에 대한 설명으로 가장 옳지 않은 것은?**
> **정답: ④ 리스트(List)는 숫자형 데이터와 문자형 데이터를 함께 저장할 수 없다.**
> **해설**: **리스트(List)**는 R에서 가장 유연한 데이터 구조로, 숫자형 벡터, 문자열, 데이터프레임 등 서로 다른 유형의 데이터를 하나의 객체 안에 함께 저장할 수 있습니다. 따라서 '함께 저장할 수 없다'는 설명은 명백히 틀렸습니다.
> - ①, ② 벡터와 행렬은 모든 원소가 동일한 데이터 타입이어야 합니다. (옳은 설명)
> - ③ 데이터프레임은 열마다 다른 데이터 타입을 가질 수 있습니다. (옳은 설명)

<a id="prob-4"></a>
**4. 다음 중 `tidyverse` 생태계에 포함된 패키지와 그 주된 용도가 올바르게 짝지어진 것은?**
> **정답: ③ `readr`: 데이터 불러오기**
> **해설**: `readr` 패키지는 `read_csv()`와 같은 함수를 제공하여 빠르고 효율적으로 CSV, TSV 등의 파일을 불러오는 역할을 합니다.
> - ① `ggplot2`는 데이터 시각화를 담당합니다.
> - ② `dplyr`은 데이터 조작(전처리)을 담당합니다.
> - ④ `tibble`은 개선된 데이터프레임 구조를 제공합니다. 문자열 처리는 `stringr` 패키지가 담당합니다.

<a id="prob-5"></a>
**5. 다음 `dplyr` 패키지의 함수 중, 데이터의 행(관측치)을 특정 조건에 따라 추출하는 기능을 수행하는 것은?**
> **정답: ③ filter()**
> **해설**: `filter()` 함수는 주어진 조건(예: `age > 20`)을 만족하는 행(row)들을 추출합니다.
> - ① `select()`: 열(column)을 선택합니다.
> - ② `arrange()`: 행을 특정 열의 값을 기준으로 정렬합니다.
> - ④ `mutate()`: 기존 열을 이용해 새로운 열을 추가합니다.

<a id="prob-6"></a>
**6. 기존 `data.frame`을 `tibble`로 변환할 때 사용하는 함수로 가장 적절한 것은?**
> **정답: ② as_tibble()**
> **해설**: `as_tibble()` 함수는 기존의 데이터프레임이나 행렬과 같은 다른 데이터 구조를 `tibble` 형태로 변환하는 역할을 합니다.
> - ① `as.data.frame()`: 다른 구조를 기본 `data.frame`으로 변환합니다.
> - ③ `read_csv()`: 외부 CSV 파일을 `tibble`로 불러옵니다.
> - ④ `tibble()`: 열(column)들을 직접 지정하여 새로운 `tibble`을 생성합니다.

---

## ✅ O/X 확인문제

**1.** [R에서 벡터(Vector)는 서로 다른 데이터 타입의 원소를 함께 저장할 수 있다.](#ox-1) **(O / X)**
**2.** [데이터프레임(Data Frame)의 모든 열은 반드시 동일한 데이터 타입이어야 한다.](#ox-2) **(O / X)**
**3.** [`tidyverse`는 데이터 과학 작업을 위한 단일 R 패키지를 의미한다.](#ox-3) **(O / X)**
**4.** [`tibble`은 기존 데이터프레임과 달리, 문자열을 자동으로 팩터(Factor)로 변환하지 않는다.](#ox-4) **(O / X)**
**5.** [`dplyr` 패키지의 `select()` 함수는 조건에 맞는 행(row)을 추출하는 데 사용된다.](#ox-5) **(O / X)**
**6.** [`dplyr` 패키지의 `arrange()` 함수는 데이터를 특정 열 기준으로 정렬하는 기능을 한다.](#ox-6) **(O / X)**
**7.** [`dplyr` 패키지의 `mutate()` 함수는 기존 열을 사용하여 새로운 열을 생성할 수 있다.](#ox-7) **(O / X)**
**8.** [파이프 연산자(`%>%`)는 코드의 가독성을 높이고 함수를 순차적으로 연결하는 데 사용된다.](#ox-8) **(O / X)**
**9.** [`group_by()` 함수는 단독으로 사용해도 데이터에 의미 있는 요약 통계를 보여준다.](#ox-9) **(O / X)**
**10.** [리스트(List)는 R에서 가장 유연한 데이터 구조로, 벡터, 행렬, 데이터프레임 등을 모두 포함할 수 있다.](#ox-10) **(O / X)**
**11.** ['Tidy Data' 원칙에서 하나의 변수(variable)는 하나의 행(row)을 구성해야 한다.](#ox-11) **(O / X)**
**12.** [`filter()` 함수는 데이터의 특정 열(column)을 선택하는 데 사용된다.](#ox-12) **(O / X)**

> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: 벡터는 모든 원소가 동일한 데이터 타입이어야 합니다.

> <a id="ox-2"></a>
> **2. 정답**: X
> **해설**: 데이터프레임은 열마다 서로 다른 데이터 타입을 가질 수 있습니다. 이것이 행렬과의 주요 차이점입니다.

> <a id="ox-3"></a>
> **3. 정답**: X
> **해설**: `tidyverse`는 `dplyr`, `ggplot2`, `readr` 등 데이터 과학을 위한 여러 패키지들의 모음(collection)입니다.

> <a id="ox-4"></a>
> **4. 정답**: O
> **해설**: `tibble`의 주요 특징 중 하나로, 사용자의 의도와 다른 자동 형 변환을 지양하여 예측 가능성을 높입니다.

> <a id="ox-5"></a>
> **5. 정답**: X
> **해설**: `select()` 함수는 열(column)을 선택하는 데 사용됩니다. 행을 추출하는 함수는 `filter()`입니다.

> <a id="ox-6"></a>
> **6. 정답**: O
> **해설**: `arrange()`는 지정된 열의 값을 기준으로 오름차순 또는 내림차순으로 행을 정렬합니다.

> <a id="ox-7"></a>
> **7. 정답**: O
> **해설**: `mutate()`는 기존 변수들을 활용하여 새로운 파생 변수를 만드는 데 매우 유용합니다.

> <a id="ox-8"></a>
> **8. 정답**: O
> **해설**: 파이프 연산자는 왼쪽의 결과를 오른쪽 함수의 첫 번째 인자로 넘겨주어, 데이터 처리 과정을 자연스럽게 연결합니다.

> <a id="ox-9"></a>
> **9. 정답**: X
> **해설**: `group_by()`는 데이터를 그룹으로 묶기만 할 뿐, 실질적인 요약은 `summarise()` 함수와 함께 사용될 때 이루어집니다.

> <a id="ox-10"></a>
> **10. 정답**: O
> **해설**: 리스트는 서로 다른 종류의 R 객체들을 담을 수 있는 유연한 '데이터 상자' 역할을 합니다.

> <a id="ox-11"></a>
> **11. 정답**: X
> **해설**: 'Tidy Data' 원칙에서 하나의 변수는 하나의 **열(column)**을 구성해야 합니다. 하나의 행은 하나의 관측치(observation)를 구성합니다.

> <a id="ox-12"></a>
> **12. 정답**: X
> **해설**: `filter()` 함수는 조건에 맞는 **행(row)**을 추출합니다. 열을 선택하는 함수는 `select()`입니다.

---

## 📖 심화 학습 예시 답안

#### 1. R의 기본 데이터 구조 5가지 비교

R은 분석 목적과 데이터의 형태에 따라 다양한 데이터 구조를 제공합니다. 각 구조의 특징과 적절한 사용 상황을 이해하는 것은 효율적인 데이터 처리를 위한 첫걸음입니다.

| 데이터 구조 | 차원 | 데이터 타입 | 특징 | 주요 사용 상황 | R 코드 예시 |
| :--- | :--- | :--- | :--- | :--- |
| **벡터(Vector)** | 1차원 | 동일 타입 | R의 가장 기본이 되는 데이터 구조. 모든 원소는 숫자, 문자, 논리형 등 동일한 타입이어야 함. | 학생들의 시험 점수 목록, 고객 이름 목록 등 단일 종류의 데이터를 나열할 때. | `scores <- c(85, 92, 78, 95)` |
| **행렬(Matrix)** | 2차원 | 동일 타입 | 행과 열을 가지는 2차원 구조. 모든 원소는 동일한 타입이어야 함. | 수학적 행렬 연산, 픽셀 데이터를 담은 이미지 처리, 동일 단위의 표 데이터. | `mat <- matrix(1:6, nrow=2, ncol=3)` |
| **배열(Array)** | 다차원 | 동일 타입 | 3차원 이상의 행렬. 모든 원소는 동일한 타입이어야 함. | 3차원 의료 영상 데이터(CT, MRI), 여러 지역/시간에 걸친 동일 지표 데이터. | `arr <- array(1:24, dim=c(3, 4, 2))` |
| **리스트(List)** | 1차원 | **다른 타입 가능** | 벡터, 행렬, 데이터프레임 등 서로 다른 데이터 구조를 하나의 객체 안에 담을 수 있는 '데이터 상자'. | 함수의 반환 값으로 여러 종류의 결과를 전달할 때, 복잡한 JSON/XML 데이터를 R 객체로 변환할 때. | `my_list <- list(name="Gildong", age=25, scores=c(90, 85))` |
| **데이터프레임(Data Frame)** | 2차원 | **열별로 다른 타입 가능** | 행과 열을 가지는 2차원 구조. 각 열은 서로 다른 데이터 타입을 가질 수 있음. 데이터 분석에서 가장 핵심적인 구조. | 엑셀 시트와 같은 대부분의 표 형태 데이터. (예: 학생 정보, 고객 구매 내역) | `df <- data.frame(name=c("A", "B"), age=c(22, 25), passed=c(TRUE, FALSE))` |


#### 2. 'Tidy Data(깔끔한 데이터)'의 세 가지 원칙
 
**Tidy Data**는 데이터 과학자 해들리 위컴(Hadley Wickham)이 제안한 데이터 구조화 표준으로, `tidyverse` 생태계의 핵심 철학입니다. 데이터가 'Tidy'하다는 것은 일관된 형태로 정리되어 있어 분석과 시각화, 모델링이 용이한 상태를 의미합니다. Tidy Data는 다음 세 가지 원칙을 따릅니다.

1.  **각 변수(Variable)는 개별 열(Column)을 구성한다.**
    -   **설명**: 데이터셋의 모든 변수는 자신만의 열을 가져야 합니다. '키', '몸무게'와 같은 측정 항목은 각각 별도의 열로 존재해야 합니다.
    -   **나쁜 예**: 하나의 '측정항목' 열에 '키'와 '몸무게'라는 값이 섞여 있고, 다른 '값' 열에 해당 수치가 있는 경우.

2.  **각 관측치(Observation)는 개별 행(Row)을 구성한다.**
    -   **설명**: 각 관측치는 자신만의 행을 가져야 합니다. 한 사람에 대한 여러 측정값(이름, 나이, 성별)은 하나의 행에 모두 포함되어야 합니다.
    -   **나쁜 예**: 2022년 데이터와 2023년 데이터가 별도의 행이 아닌 별도의 열(`sales_2022`, `sales_2023`)로 존재하는 경우.

3.  **각 유형의 관측 단위(Observational unit)는 개별 테이블(Table)을 구성한다.**
    -   **설명**: 서로 다른 유형의 데이터는 별도의 테이블로 분리해야 합니다. 예를 들어, '학생 정보' 테이블과 '수강 과목 정보' 테이블은 분리하고, '학생 ID'와 같은 공통 키로 연결해야 합니다.

**중요성**: 데이터가 Tidy Data 원칙을 따르면, `dplyr`로 데이터를 조작하고 `ggplot2`로 시각화하는 작업이 매우 직관적이고 간단해집니다. 데이터의 구조가 예측 가능하므로, 분석가는 데이터의 형태를 바꾸는 데 시간을 낭비하지 않고 분석 자체에 더 집중할 수 있습니다. 이는 데이터 분석의 생산성과 재현성을 크게 향상시킵니다.

#### 3. `dplyr` 함수 조합을 사용한 데이터 편집 시나리오

`dplyr`의 가장 큰 강점은 각 기능이 명확한 함수(동사)들을 파이프 연산자(`%>%`)로 연결하여, 사람이 생각하는 순서대로 데이터 처리 과정을 자연스럽게 코드로 표현할 수 있다는 점입니다.

**시나리오**: R에 내장된 `iris` 데이터셋을 사용하여, "붓꽃의 종류(Species)가 `setosa`이면서, 꽃받침의 길이(Sepal.Length)가 5.0 이상인 데이터를 찾아, 꽃잎의 너비(Petal.Width)를 기준으로 내림차순 정렬하고, 꽃받침의 길이와 너비의 비율을 나타내는 `Sepal.Ratio`라는 새로운 변수를 추가"하는 작업을 수행해 보겠습니다.

```R
# 필요한 라이브러리를 로드합니다.
library(dplyr)

# iris 데이터셋을 tibble로 변환하여 사용합니다.
iris_tb <- as_tibble(iris)

result <- iris_tb %>%
  # 1. Species가 'setosa'인 데이터만 필터링 (filter)
  filter(Species == "setosa") %>%
  
  # 2. Sepal.Length가 5.0 이상인 데이터만 추가 필터링 (filter)
  filter(Sepal.Length >= 5.0) %>%
  
  # 3. Petal.Width를 기준으로 내림차순 정렬 (arrange)
  arrange(desc(Petal.Width)) %>%
  
  # 4. Sepal.Ratio 파생변수 추가 (mutate)
  mutate(Sepal.Ratio = Sepal.Length / Sepal.Width) %>%
  
  # 5. 필요한 열만 선택하여 결과 확인 (select)
  select(Species, Sepal.Length, Petal.Width, Sepal.Ratio)

# 최종 결과 출력
print(result)
```

**코드 해설**:
- `iris_tb %>% ...`: `iris_tb` 데이터를 다음 함수로 넘깁니다.
- `filter(Species == "setosa")`: `Species` 열의 값이 "setosa"인 행만 남깁니다.
- `filter(Sepal.Length >= 5.0)`: 앞선 결과에서 `Sepal.Length`가 5.0 이상인 행만 다시 남깁니다.
- `arrange(desc(Petal.Width))`: `Petal.Width` 열을 기준으로 내림차순(`desc`)으로 정렬합니다.
- `mutate(Sepal.Ratio = ...)`: `Sepal.Length`를 `Sepal.Width`로 나눈 값을 `Sepal.Ratio`라는 새 열로 추가합니다.
- `select(...)`: 최종적으로 보고 싶은 열들만 선택하여 결과를 정리합니다.

---

## 🌐 최신 동향 및 추가 정보

### 1. R과 Python의 공존: `reticulate` 패키지
과거에는 R과 Python이 데이터 과학 분야에서 경쟁하는 구도였지만, 현재는 각 언어의 강점을 함께 활용하는 방향으로 나아가고 있습니다. `reticulate` 패키지는 R 환경에서 Python 코드를 직접 실행하고, R 객체와 Python 객체를 서로 변환할 수 있게 해줍니다. 이를 통해 R의 강력한 통계/시각화 기능과 Python의 방대한 머신러닝/딥러닝 라이브러리(TensorFlow, PyTorch) 생태계를 하나의 분석 프로젝트 안에서 자유롭게 넘나들 수 있습니다.

### 2. 더 빨라진 데이터 처리: `data.table`과 `dtplyr`
`tidyverse`의 `dplyr`은 직관적이고 가독성이 뛰어나지만, 수백만 행 이상의 매우 큰 데이터를 다룰 때는 속도가 느려질 수 있습니다. `data.table`은 대용량 데이터의 집계, 조인, 그룹화 작업을 메모리 효율적으로 매우 빠르게 처리하도록 설계된 R 패키지입니다. 최근에는 `dtplyr` 패키지를 통해 `dplyr`의 직관적인 문법을 사용하면서도 내부적으로는 `data.table`의 빠른 엔진을 활용하여 코드 가독성과 실행 속도를 모두 잡으려는 시도가 활발히 이루어지고 있습니다.

### 3. 인터랙티브 시각화와 웹 애플리케이션: `shiny`
정적인 그래프를 넘어 사용자와 상호작용하는 동적인 데이터 시각화와 웹 애플리케이션을 R만으로 손쉽게 만들 수 있는 `shiny` 패키지의 인기가 계속되고 있습니다. 데이터 분석 결과를 단순히 보고서로 전달하는 것을 넘어, 사용자가 직접 파라미터를 조절하며 결과를 탐색할 수 있는 대시보드를 제작하여 분석의 활용도를 극대화할 수 있습니다.

---

## 📚 핵심 용어집 (Glossary)

- **R**: 통계 계산과 데이터 시각화에 특화된 오픈소스 프로그래밍 언어 및 분석 환경.
- **RStudio**: R을 더 편리하고 효율적으로 사용할 수 있도록 코드 편집기, 콘솔, 시각화 창, 디버거 등 다양한 기능을 통합하여 제공하는 IDE(통합 개발 환경).
- **패키지 (Package)**: 특정 기능을 수행하는 R 함수, 데이터, 코드의 묶음. `install.packages()`로 설치하고 `library()`로 불러와 사용한다.
- **벡터 (Vector)**: R의 가장 기본적인 데이터 구조로, 동일한 데이터 타입의 원소들로 이루어진 1차원 배열.
- **데이터프레임 (Data Frame)**: 행과 열로 구성된 2차원 표 형태의 데이터 구조. 각 열은 서로 다른 데이터 타입을 가질 수 있어, 엑셀 시트와 유사하다.
- **Tidyverse**: 데이터 과학 작업을 더 쉽고 일관되게 만들기 위한 R 패키지들의 모음. `dplyr`, `ggplot2`, `readr` 등이 포함된다.
- **Tidy Data**: "각 변수는 열, 각 관측치는 행, 각 관측 단위는 테이블"이라는 원칙을 따르는 깔끔하게 정돈된 데이터 구조.
- **Tibble**: `tidyverse` 생태계의 표준 데이터프레임. 기존 `data.frame`의 불편한 점을 개선하여 더 엄격하고 사용자 친화적인 특징을 가진다.
- **dplyr**: 데이터 조작(전처리)을 위한 `tidyverse`의 핵심 패키지. `select`, `filter` 등 직관적인 '동사' 함수들을 제공한다.
- **파이프 연산자 (`%>%`)**: `magrittr` 패키지에서 제공하는 연산자로, 왼쪽 객체를 오른쪽 함수의 첫 번째 인자로 전달하여 코드의 가독성을 높이고 함수를 체인처럼 연결해준다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

이 섹션은 NotebookLM과 같은 AI 학습 파트너가 본문의 내용을 더 깊이 이해하고, 다양한 관점의 질문에 효과적으로 답변할 수 있도록 돕기 위한 추가 자료입니다.

### 1. 관점별 비교: `dplyr` vs. `Base R` vs. `SQL`

> **상황**: '고객' 테이블에서 'VIP' 등급이고, '가입일'이 2023년 이후인 고객의 '이름'과 '이메일'을 '최근 구매일' 순으로 정렬하여 조회하고 싶습니다. 이 작업을 세 가지 다른 방식으로 어떻게 수행할 수 있을까요?

| 구분 | `dplyr` (Tidyverse) | `Base R` (기본 R) | `SQL` (데이터베이스) |
| :--- | :--- | :--- | :--- |
| **코드 예시** | `customers %>% filter(grade == "VIP", join_date >= "2023-01-01") %>% arrange(desc(last_purchase)) %>% select(name, email)` | `subset_data <- customers[customers$grade == "VIP" & customers$join_date >= "2023-01-01", ]<br>sorted_data <- subset_data[order(subset_data$last_purchase, decreasing = TRUE), ]<br>result <- sorted_data[, c("name", "email")]` | `SELECT name, email FROM customers WHERE grade = 'VIP' AND join_date >= '2023-01-01' ORDER BY last_purchase DESC;` |
| **장점** | 생각의 흐름대로 코드를 작성하여 가독성이 매우 높음. | 추가 패키지 설치가 필요 없음. | 대용량 데이터를 서버에서 직접 효율적으로 처리 가능. |
| **단점** | 패키지 설치 및 로드가 필요함. | 코드가 길어지고 중간 결과를 변수에 계속 저장해야 함. | 데이터베이스에 대한 지식이 필요하며, R로 데이터를 가져온 후 추가 분석이 필요할 수 있음. |

### 2. 오개념 바로잡기 (Common Misconceptions)

- **오개념 1: "파이프 연산자(`%>%`)는 R의 기본 기능이다."**
  - **바로잡기**: 파이프 연산자는 R에 내장된 기본 기능이 아니라, `magrittr`라는 패키지가 제공하는 기능입니다. `tidyverse`를 불러오면 `magrittr`가 함께 로드되기 때문에 마치 기본 기능처럼 편리하게 사용할 수 있는 것입니다. (참고: R 4.1.0 버전부터는 기본 파이프 연산자 `|>`가 도입되었지만, `tidyverse`에서는 여전히 `%>%`가 주로 사용됩니다.)

- **오개념 2: "`select()`는 행(row)을, `filter()`는 열(column)을 선택한다."**
  - **바로잡기**: 정반대입니다. 이 두 함수는 `dplyr` 초보자가 가장 많이 헷갈리는 부분입니다.
    - `select()`: 열(column, 변수)을 선택하거나 제외합니다. (세로 방향 선택)
    - `filter()`: 조건에 맞는 행(row, 관측치)을 남깁니다. (가로 방향 필터링)

- **오개-념 3: "`=`와 `==`는 `filter()` 안에서 동일하게 작동한다."**
  - **바로잡기**: 절대 그렇지 않습니다.
    - `==`: '같다'를 의미하는 **비교 연산자**입니다. `filter(Species == "setosa")`는 `Species`가 "setosa"인 행을 찾습니다.
    - `=`: 변수에 값을 **할당하는 연산자**입니다. `filter()` 안에서 비교 목적으로 사용하면 의도치 않은 결과를 낳거나 오류가 발생합니다. `mutate(New_Column = Old_Column * 2)`처럼 새 변수를 만들 때 주로 사용합니다.

---

## 📚 참고 자료 (References)

- R for Data Science (2e): `tidyverse` 개발자인 해들리 위컴이 직접 쓴 데이터 과학 입문서. (영문, 온라인 무료 공개)
- RStudio Cheatsheets: `dplyr`, `ggplot2` 등 `tidyverse` 핵심 패키지들의 기능이 보기 쉽게 정리된 자료.
- Welcome to the Tidyverse: `tidyverse` 공식 홈페이지.
- swirl: R 콘솔에서 직접 R 프로그래밍과 데이터 과학을 대화형으로 배울 수 있는 패키지.

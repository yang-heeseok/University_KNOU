# 04. 파이썬컴퓨팅: 기본 자료구조의 이해

## 학습 목표
1. 파이썬의 기본 자료 구조인 리스트의 개념과 특징, 그리고 파이썬에서 제공하는 연산 함수를 학습한다.
2. 파이썬의 기본 자료 구조인 튜플의 개념과 특징, 그리고 파이썬에서 제공하는 연산 함수를 학습하고 리스트와의 차이점을 이해한다.
3. 파이썬의 기본 자료 구조인 집합의 개념과 특징, 그리고 파이썬에서 제공하는 연산 함수를 학습한다.
4. 파이썬의 기본 자료 구조인 딕셔너리의 개념과 특징, 그리고 파이썬에서 제공하는 연산 함수를 학습하고 집합과의 차이점을 이해한다.

---

## 📝 요약 (Summary)
1.  **리스트(List)**: 순서가 있고, 값을 **변경할 수 있는(mutable)** 데이터의 모음입니다. 대괄호(`[]`)를 사용하여 생성하며, 다양한 타입의 데이터를 함께 저장할 수 있습니다. (예: `my_list = [1, "hello", 3.14]`)
2.  **튜플(Tuple)**: 순서가 있지만, 값을 **변경할 수 없는(immutable)** 데이터의 모음입니다. 소괄호(`()`)를 사용하여 생성하며, 한 번 생성된 후에는 내부의 값을 수정, 추가, 삭제할 수 없습니다. (예: `my_tuple = (1, 2, 3)`)
3.  **집합(Set)**: 순서가 없고, **중복된 값을 허용하지 않는** 데이터의 모음입니다. 중괄호(`{}`)를 사용하여 생성하며, 합집합, 교집합 등 수학적 집합 연산에 유용합니다. (예: `my_set = {1, 2, 3, 3}` -> `{1, 2, 3}`)
4.  **딕셔너리(Dictionary)**: **Key-Value 쌍**으로 데이터를 저장하는 자료구조입니다. 순서가 없으며(Python 3.7+ 부터는 입력 순서 유지), Key는 중복될 수 없습니다. 중괄호(`{}`)를 사용하여 생성하며, Key를 통해 값을 빠르게 조회할 수 있습니다. (예: `my_dict = {"name": "홍길동", "age": 25}`)

---

## ✏️ 심화 학습 (Study Subject)
1.  **가상 시나리오: "어떤 자료구조를 써야 할까?" (데이터 구조 선택 가이드)**
    - **상황**: 간단한 온라인 강의 관리 시스템을 만든다고 가정해 봅시다. 각 기능에 가장 적합한 자료구조는 무엇일까요?
        - **수강생 명단 관리**: 수시로 학생이 추가되거나 빠질 수 있으므로, **변경 가능한(mutable)** `리스트(list)`가 적합합니다. (예: `students = ["김철수", "이영희"]`, `students.append("박지성")`)
        - **학기별 고정 공휴일 저장**: 한번 정해지면 바뀌지 않아야 할 데이터이므로, **변경 불가능한(immutable)** `튜플(tuple)`이 안전합니다. (예: `holidays = ("2024-01-01", "2024-03-01")`)
        - **특정 과목 수강생 ID 목록**: 중복된 학생 등록을 막고, 특정 학생이 수강 중인지 빠르게 확인해야 하므로, **중복을 허용하지 않는** `집합(set)`이 효율적입니다. (예: `python_class = {101, 102, 103}`, `102 in python_class`)
        - **학생별 상세 정보 관리**: '학번'이라는 고유한 키(Key)로 학생의 이름, 학과, 점수 등 다양한 정보를 관리해야 하므로, **Key-Value 쌍**의 `딕셔너리(dictionary)`가 최적입니다. (예: `student_info = {101: {"name": "김철수", "major": "CS"}}`)
    - **AI 학습 포인트**: 이 시나리오는 각 자료구조의 핵심 특징이 실제 문제 해결에 어떻게 적용되는지 명확히 보여줍니다. AI 학습 도우미에게 "만약 학생 정보를 리스트의 리스트(`[ [101, "김철수"], [102, "이영희"] ]`)로 저장한다면 딕셔너리에 비해 어떤 단점이 있을까요?"라고 질문하여 데이터 조회 성능의 차이를 탐색하게 할 수 있습니다.

2.  **관점별 비교 및 오개념 분석: Mutable vs. Immutable**
    - **핵심 비교**: 파이썬 자료구조는 '변경 가능성(Mutability)'에 따라 나뉩니다.
        - **Mutable (변경 가능)**: `리스트`, `딕셔너리`, `집합`. 생성 후에도 요소를 추가, 수정, 삭제할 수 있습니다.
        - **Immutable (변경 불가능)**: `튜플`, `문자열`, `숫자`. 생성 후에는 내부 값을 바꿀 수 없습니다. 값을 바꾸려면 새로운 객체를 만들어야 합니다.
    - **오개념 1: 튜플은 항상 안전하다?**
        - **분석**: `my_tuple = (1, 2, [3, 4])` 와 같이 튜플 안에 변경 가능한(mutable) 객체인 리스트가 포함될 수 있습니다. 이 경우, 튜플 자체의 구조(`my_tuple[2] = ...`)는 바꿀 수 없지만, 튜플 안의 리스트 내용(`my_tuple[2].append(5)`)은 변경할 수 있습니다. 즉, 튜플의 불변성은 튜플이 담고 있는 '객체 참조'에 대한 것이지, 그 객체의 '내부 내용'까지 보장하는 것은 아닙니다.
    - **오개념 2: 딕셔너리 키(Key)는 아무거나 써도 된다?**
        - **분석**: 딕셔너리의 키는 반드시 **변경 불가능한(immutable)** 객체여야 합니다. 왜냐하면 딕셔너리는 키를 해싱(hashing)하여 값을 빠르게 찾는데, 만약 키가 변경되면 해시값도 변경되어 값을 찾을 수 없게 되기 때문입니다. 따라서 숫자, 문자열, 튜플은 키가 될 수 있지만, 리스트나 다른 딕셔너리는 키로 사용할 수 없습니다.
        - **잘못된 예**: `my_dict = {[1, 2]: "value"}` -> `TypeError: unhashable type: 'list'`
        - **올바른 예**: `my_dict = {(1, 2): "value"}`
---

## ❓ 연습 문제 및 해설

### 📝 문제

**1. 파이썬의 튜플은 어떤 특징을 가지는가?**
   > ① 순서가 있고 변경 가능하다.
   > ② 순서가 있고 변경 불가능하다.
   > ③ 순서가 없고 변경 가능하다.
   > ④ 순서가 없고 변경 불가능하다.

<br>

**2. 파이썬에서 리스트를 정의하는 방법으로 올바른 기호는 무엇인가?**
   > ① `( )`
   > ② `{ }`
   > ③ `[ ]`
   > ④ `< >`

<br>

**3. 다음 중 딕셔너리에서 특정 키에 해당하는 값을 변경하는 방법으로 올바른 것은?**
   > ① 대입 연산자(`=`)를 사용하여 새로운 값을 할당한다.
   > ② `insert()` 메서드를 사용하여 값을 추가한다.
   > ③ `update()` 메서드를 사용하여 값을 변경한다.
   > ④ `remove()` 메서드를 사용하여 값을 삭제한다.

---

### 🔑 정답

1. ②
2. ③
3. ①

---

### 🧐 해설

<a id="prob-1"></a>
**1. 파이썬의 튜플은 어떤 특징을 가지는가?**
> **정답: ② 순서가 있고 변경 불가능하다.**
> **해설**: 튜플(Tuple)은 생성 후에는 그 내용을 수정, 추가, 삭제할 수 없는 **변경 불가능(immutable)**한 특징을 가집니다. 리스트와 같이 인덱스를 통해 각 요소에 접근할 수 있으므로 **순서가 있습니다.**

<a id="prob-2"></a>
**2. 파이썬에서 리스트를 정의하는 방법으로 올바른 기호는 무엇인가?**
> **정답: ③ `[ ]`**
> **해설**: 파이썬에서는 대괄호(`[]`)를 사용하여 리스트를 정의하고, 소괄호(`()`)는 튜플, 중괄호(`{}`)는 집합 또는 딕셔셔리를 정의하는 데 사용됩니다.

<a id="prob-3"></a>
**3. 다음 중 딕셔너리에서 특정 키에 해당하는 값을 변경하는 방법으로 올바른 것은?**
> **정답: ① 대입 연산자(`=`)를 사용하여 새로운 값을 할당한다.**
> **해설**: 딕셔너리의 값은 `my_dict['key'] = new_value`와 같이 대입 연산자를 사용하여 쉽게 변경할 수 있습니다. `update()` 메서드는 다른 딕셔너리를 병합하는 데 주로 사용되며, `insert()`와 `remove()`는 리스트에서 사용하는 메서드입니다.

---

## ✅ O/X 확인문제(연습문항 개수의 2배)

**1.** [리스트는 한 번 생성되면 그 길이나 요소를 변경할 수 없다.](#ox-1) **(O / X)**
**2.** [튜플은 `append()` 메서드를 사용하여 새로운 요소를 추가할 수 있다.](#ox-2) **(O / X)**
**3.** [집합(set)은 중복된 값을 허용하지 않으므로, `my_set = {1, 2, 2, 3}`은 `{1, 2, 3}`으로 저장된다.](#ox-3) **(O / X)**
**4.** [딕셔너리의 키(key)로는 리스트를 사용할 수 있다.](#ox-4) **(O / X)**
**5.** [리스트, 튜플, 집합은 모두 순서가 있는(ordered) 자료구조이다.](#ox-5) **(O / X)**
**6.** [튜플 내부에 리스트가 있는 경우, 그 리스트의 내용은 변경할 수 있다.](#ox-6) **(O / X)**

> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: 리스트(List)는 **변경 가능한(mutable)** 자료구조로, 생성 후에도 `append()`, `remove()`, 인덱싱을 통한 값 변경 등으로 요소를 추가, 삭제, 수정할 수 있습니다.

> <a id="ox-2"></a>
> **2. 정답**: X
> **해설**: 튜플(Tuple)은 **변경 불가능한(immutable)** 자료구조이므로, 요소를 추가하거나 삭제하는 메서드(`append()`, `remove()` 등)를 제공하지 않습니다.

> <a id="ox-3"></a>
> **3. 정답**: O
> **해설**: 집합(Set)의 가장 중요한 특징 중 하나는 **중복을 허용하지 않는다**는 것입니다. 따라서 중복된 값을 포함하여 집합을 생성하면 자동으로 중복이 제거됩니다.

> <a id="ox-4"></a>
> **4. 정답**: X
> **해설**: 딕셔너리의 키(Key)는 반드시 **변경 불가능한(immutable)** 객체여야 합니다. 리스트는 변경 가능하므로 키로 사용할 수 없으며, 사용 시 `TypeError`가 발생합니다.

> <a id="ox-5"></a>
> **5. 정답**: X
> **해설**: 리스트와 튜플은 인덱스를 가지는 순서가 있는 자료구조이지만, 집합(Set)은 순서가 없습니다.

> <a id="ox-6"></a>
> **6. 정답**: O
> **해설**: 튜플 자체는 변경 불가능하지만, 튜플이 담고 있는 요소가 변경 가능한 객체(예: 리스트)일 경우, 그 객체의 내부 내용은 변경할 수 있습니다. (예: `my_tuple = (1, [2, 3])`에서 `my_tuple[1].append(4)`는 가능)

---

## 📖 심화 학습 예시 답안

#### 1. 자료구조별 주요 연산 및 시간 복잡도(Big-O)

알고리즘의 효율성을 나타내는 시간 복잡도는 데이터의 양이 증가할 때 연산 시간이 어떻게 변하는지를 보여줍니다. `O(1)`은 데이터 크기와 상관없이 항상 일정한 시간이 걸리는 가장 효율적인 경우이며, `O(n)`은 데이터 크기에 비례하여 시간이 걸림을 의미합니다.

1.  **리스트 (List)**:
    - **인덱스로 접근 `my_list[i]`**: `O(1)`. 인덱스를 통해 바로 접근하므로 매우 빠릅니다.
    - **맨 뒤에 요소 추가 `append()`**: `O(1)`. 리스트의 끝에 요소를 추가하는 것은 효율적입니다.
    - **중간에 요소 추가/삭제 `insert()`, `pop(i)`**: `O(n)`. 중간에 요소를 추가하거나 삭제하면 그 뒤의 모든 요소들을 한 칸씩 이동시켜야 하므로 데이터가 많을수록 느려집니다.
    - **값으로 요소 탐색 `x in my_list`**: `O(n)`. 원하는 값을 찾기 위해 처음부터 끝까지 모든 요소를 확인해야 할 수 있습니다.

2.  **집합 (Set) & 딕셔너리 (Dictionary)**:
    - **요소 추가/삭제/탐색 `add()`, `remove()`, `x in my_set`**: 평균 `O(1)`. 내부적으로 해시(Hash) 테이블을 사용하므로 데이터 양과 관계없이 매우 빠르게 요소를 찾거나 추가/삭제할 수 있습니다. 이것이 리스트의 `in` 연산보다 집합의 `in` 연산이 훨씬 빠른 이유입니다.

#### 2. 파이썬 자료구조 선택 가이드 (성능 및 특징 비교)

각 자료구조의 특징을 이해하고 상황에 맞게 사용하는 것이 중요합니다.

| 구분 | 리스트 (List) | 튜플 (Tuple) | 집합 (Set) | 딕셔너리 (Dictionary) |
| :--- | :--- | :--- | :--- | :--- |
| **구조** | 순서가 있는 데이터의 모음 | 순서가 있는 데이터의 모음 | 순서가 없는 데이터의 모음 | Key-Value 쌍의 모음 |
| **변경 가능성** | **Mutable (변경 가능)** | **Immutable (변경 불가능)** | **Mutable (변경 가능)** | **Mutable (변경 가능)** |
| **중복** | 허용 | 허용 | **허용 안 함** | Key는 중복 불가, Value는 허용 |
| **탐색 속도** | 느림 `O(n)` | 느림 `O(n)` | **빠름** `O(1)` | **빠름** `O(1)` (Key 기준) |
| **주요 용도** | 순서가 중요하고, 데이터 변경이 잦을 때 | 함수 반환값, 좌표 등 **변경되면 안 되는** 데이터를 묶을 때 | 데이터의 **중복 제거**, 멤버십 테스트(존재 여부 확인) | 고유한 식별자(Key)로 데이터를 관리하고 싶을 때 |
| **생성 예시** | `[1, "a", 2]` | `(1, "a", 2)` | `{1, "a", 2}` | `{"id": 1, "name": "a"}` |

#### 3. Comprehension을 활용한 효율적인 자료구조 생성

파이썬에서는 for 반복문보다 더 간결하고 효율적으로 자료구조를 생성할 수 있는 **Comprehension** 문법을 제공합니다.

- **리스트 컴프리헨션 (List Comprehension)**
  ```python
  # 0부터 9까지의 수 중에서 짝수만 제곱하여 리스트 만들기
  squares = [x**2 for x in range(10) if x % 2 == 0]
  # 결과: [0, 4, 16, 36, 64]
  ```
- **집합 컴프리헨션 (Set Comprehension)**
  ```python
  # 리스트에서 중복된 과일 이름을 제거하고 집합으로 만들기
  fruits = ["apple", "banana", "apple", "orange"]
  unique_fruits = {fruit for fruit in fruits}
  # 결과: {'apple', 'banana', 'orange'}
  ```
- **딕셔너리 컴프리헨션 (Dictionary Comprehension)**
  ```python
  # 두 리스트를 묶어 학생 이름과 점수로 딕셔너리 만들기
  students = ["철수", "영희"]
  scores = [90, 85]
  score_dict = {name: score for name, score in zip(students, scores)}
  # 결과: {'철수': 90, '영희': 85}
  ```

---

## 🌐 최신 동향 및 추가 정보

### 1. 파이썬 버전별 딕셔너리 변화: 순서가 보장되다!
- **과거 (Python 3.6 이전)**: 딕셔너리는 순서가 없는(unordered) 자료구조였습니다. `{'a': 1, 'b': 2}`를 생성해도, 출력 시 순서가 다르게 나올 수 있었습니다. 이는 해시 테이블의 내부 구현 방식 때문이었습니다.
- **현재 (Python 3.7 이상)**: 딕셔너리가 **입력된 순서를 기억하고 보장**하게 되었습니다. 이는 CPython 3.6에서 우연히 구현되었고, 3.7부터 공식적인 언어 사양이 되었습니다. 이제 딕셔너리는 순서가 필요한 시나리오에서도 유용하게 사용될 수 있습니다.
  ```python
  # Python 3.7+
  my_dict = {'c': 3, 'a': 1, 'b': 2}
  print(list(my_dict.keys())) # 출력: ['c', 'a', 'b'] (입력 순서 보장)
  ```
- **중요성**: 이 변화로 인해, 과거에는 순서 보장을 위해 `collections.OrderedDict`를 사용해야 했지만, 이제는 기본 `dict`만으로도 충분한 경우가 많아졌습니다.

### 2. 타입 힌트(Type Hints)와 자료구조
- **개념**: 최신 파이썬(3.5+)에서는 **타입 힌트**를 사용하여 변수나 함수의 인자, 반환값이 어떤 타입을 가져야 하는지 명시할 수 있습니다. 이는 코드의 가독성을 높이고, 잠재적인 버그를 예방하는 데 큰 도움이 됩니다. (코드를 실행하는 데 필수는 아닙니다.)
- **사용법**: `typing` 모듈과 함께 사용하여 복잡한 자료구조의 타입을 명확히 표현할 수 있습니다.
  ```python
  from typing import List, Tuple, Set, Dict

  # 각 자료구조에 대한 타입 힌트 예시
  student_ids: List[int] = [101, 102, 103]
  coordinates: Tuple[int, int] = (10, 20)
  unique_tags: Set[str] = {"python", "data", "ai"}
  
  # 딕셔너리: 키는 문자열(str), 값은 정수(int)
  student_scores: Dict[str, int] = {"철수": 90, "영희": 85}
  ```
- **AI 학습 포인트**: AI 학습 도우미에게 "타입 힌트를 사용했을 때의 장점과 단점을 알려줘" 또는 "복잡한 중첩 자료구조(예: 리스트 안에 딕셔너리가 있는 구조)에 대한 타입 힌트는 어떻게 작성해야 해?"라고 질문하여 더 깊이 있는 학습을 진행할 수 있습니다.

---

## 📚 핵심 용어집 (Glossary)

- **Mutable (변경 가능 객체)**: 객체가 생성된 후에도 내부의 값(요소)을 수정, 추가, 삭제할 수 있는 데이터 타입입니다. (예: 리스트, 딕셔너리, 집합)
- **Immutable (변경 불가능 객체)**: 객체가 생성된 후에는 내부의 값을 변경할 수 없는 데이터 타입입니다. 값을 변경하려면 새로운 객체를 생성해야 합니다. (예: 튜플, 문자열, 숫자, bool)
- **시퀀스 (Sequence)**: 데이터에 순서(인덱스)가 부여되어 있는 자료구조로, 인덱싱과 슬라이싱을 통해 요소에 접근할 수 있습니다. (예: 리스트, 튜플, 문자열)
- **해싱 (Hashing)**: 임의의 길이의 데이터를 고정된 길이의 데이터(해시 값)로 매핑하는 과정입니다. 딕셔너리와 집합은 이 해싱 기법을 통해 매우 빠른 데이터 검색(평균 `O(1)`)을 지원합니다. 이 때문에 딕셔너리의 키는 반드시 해싱 가능한(hashable), 즉 변경 불가능한(immutable) 객체여야 합니다.
- **컴프리헨션 (Comprehension)**: 기존의 자료구조를 기반으로 간결하고 효율적으로 새로운 자료구조(리스트, 집합, 딕셔너리)를 생성하는 파이썬의 강력한 문법입니다. (예: `[x*2 for x in range(5)]`)
- **시간 복잡도 (Time Complexity)**: 알고리즘의 성능을 나타내는 척도로, 입력 데이터의 크기(n)가 증가함에 따라 연산 실행 시간이 어떻게 변하는지를 나타냅니다. `O(1)`은 데이터 크기와 무관하게 일정한 시간이 걸림을, `O(n)`은 데이터 크기에 비례하여 시간이 걸림을 의미합니다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. 자료구조 성능 비교 심화 질문
> **프롬프트 예시**: "100만 개의 숫자 중에서 특정 숫자가 존재하는지 확인하는 작업을 수행해야 합니다. 리스트를 사용하는 것과 집합을 사용하는 것의 이론적인 성능 차이(시간 복잡도)를 설명하고, 실제 파이썬 코드로 실행 시간을 측정하여 비교 결과를 보여주세요. 왜 이런 차이가 발생하는지 해시 테이블(hash table)의 원리와 연관 지어 설명해주세요."

### 2. 자료구조 선택 능력 강화 시나리오
> **프롬프트 예시**: "당신은 소프트웨어 아키텍트입니다. '실시간 주식 거래 시스템'을 설계한다고 가정할 때, 다음 각 데이터 유형을 저장하기 위해 어떤 파이썬 자료구조를 선택할 것이며 그 이유는 무엇인지 설명해주세요.
> 1.  실시간으로 수신되는 모든 거래 기록 (체결 시간, 가격, 수량)
> 2.  각 종목 코드(예: '005930')와 현재가(price)를 매핑하여 관리
> 3.  사용자가 설정한 관심 종목 목록 (중복 없이 관리)
> 4.  한 번 설정하면 바뀌지 않는 시장의 개장 및 폐장 시간"

### 3. 오류 분석 및 디버깅 능력 향상 질문
> **프롬프트 예시**: "다음 파이썬 코드는 실행 시 `TypeError`를 발생시킵니다.
> ```python
> my_data = {[1, 2]: "A", (3, 4): "B"}
> ```
> 1. 이 코드가 왜 오류를 발생시키는지 딕셔너리 키의 '해싱 가능(hashable)' 특성과 연관 지어 설명해주세요.
> 2. 이 문제를 해결하여 `[1, 2]`를 키처럼 사용하고 싶을 때, 어떤 자료구조로 변환하여 키로 사용할 수 있는지 올바른 코드 예시를 보여주세요."

---

## 📚 참고 자료 (References)

- 파이썬 공식 문서 - 자료 구조 (Data Structures)
- 파이썬 공식 문서 - typing — 타입 힌트 지원
- Real Python - Python's Mutable vs Immutable Types: What's the Difference?
# 06. 파이썬컴퓨팅: 함수의 이해와 활용

## 학습 목표
1. 파이썬에서 매개 변수와 인수, 변수의 범위 등을 고려해서 함수를 정의하는 방법에 대해서 학습한다.
2. 파이썬에서 다양한 매개 변수와 출력을 고려해서 함수를 호출하는 방법에 대해서 학습한다.
3. 파이썬에서 제공하는 독특한 함수 사용 방법에 대해서 학습함으로써 파이썬의 함수 호출 기능을 효과적으로 사용하는 능력을 함양한다.

---

## 📝 요약 (Summary)
1.  **함수 (Function)**: 특정 작업을 수행하는 코드의 묶음으로, **재사용성**을 높이고 코드를 **모듈화**하여 관리하기 쉽게 만듭니다. `def` 키워드를 사용하여 정의하며, 입력(매개변수)을 받아 처리한 후 결과(반환값)를 출력할 수 있습니다.
2.  **매개변수 (Parameter)와 인수 (Argument)**: **매개변수**는 함수를 정의할 때 선언하는 변수이며, **인수**는 함수를 호출할 때 전달하는 실제 값입니다. 파이썬은 위치 인수, 키워드 인수, 기본값 매개변수, 그리고 가변 길이 인수(`*args`, `**kwargs`) 등 다양한 방식으로 인수를 전달할 수 있어 유연한 함수 호출이 가능합니다.
3.  **변수의 범위 (Scope)**: 변수가 유효한 코드의 범위를 의미하며, 함수 안에서 선언된 **지역 변수(Local Variable)**와 함수 바깥에서 선언된 **전역 변수(Global Variable)**로 나뉩니다. `global` 키워드를 사용하면 함수 내에서 전역 변수의 값을 직접 수정할 수 있습니다.
4.  **람다 (Lambda) 함수**: 이름이 없는 한 줄짜리 익명 함수로, 간단한 기능을 구현할 때 코드를 간결하게 만들어 줍니다. 주로 다른 함수의 인수로 전달될 때 유용하게 사용됩니다. (예: `lambda x, y: x + y`)

---

## ✏️ 심화 학습 (Study Subject)
1.  **가상 시나리오: "유연한 성적 처리 시스템 만들기"**
    - **상황**: 학생들의 성적을 처리하는 함수를 만들어야 합니다. 어떤 학생은 필수 과목 점수만 있고, 다른 학생은 선택 과목 점수도 추가로 있습니다. 모든 경우를 처리할 수 있는 유연한 함수가 필요합니다.
    - **해결**: 가변 인수 `*args`와 `**kwargs`를 사용하면 이 문제를 효과적으로 해결할 수 있습니다. 필수 과목은 일반 매개변수로 받고, 추가적인 선택 과목들은 `**kwargs`로 받아 처리할 수 있습니다.
      ```python
      def calculate_score(name, *required_scores, **optional_scores):
          total = sum(required_scores)
          print(f"{name}의 필수과목 총점: {total}")
          if optional_scores:
              print("--- 선택과목 점수 ---")
              for subject, score in optional_scores.items():
                  print(f"{subject}: {score}")
      
      calculate_score("김철수", 90, 85, 영어=95, 과학=88)
      calculate_score("이영희", 75, 80)
      ```
    - **AI 학습 포인트**: AI 학습 도우미에게 "위 `calculate_score` 함수에서 `*args`와 `**kwargs`의 순서를 바꾸면 왜 `SyntaxError`가 발생하나요?"라고 질문하여 파이썬 함수의 매개변수 순서 규칙(일반 매개변수 -> `*args` -> `**kwargs`)을 깊이 있게 학습할 수 있습니다.

2.  **관점별 비교 및 오개념 분석: 지역 변수 vs. 전역 변수**
    - **핵심 비교**: 변수의 '생존 기간'과 '영향 범위'의 차이
        - **지역 변수 (Local Variable)**: 함수 **내부**에서 생성되며, 함수가 호출될 때 만들어졌다가 함수 실행이 끝나면 사라집니다. 오직 그 함수 안에서만 접근할 수 있습니다.
        - **전역 변수 (Global Variable)**: 프로그램 **전체**에서 접근 가능한 변수입니다. 프로그램이 시작될 때 만들어져 끝날 때까지 유지됩니다.
    - **오개념 1: 함수 안에서 전역 변수를 마음대로 수정할 수 있다?**
        - **분석**: 함수 내에서 전역 변수와 같은 이름의 변수에 값을 할당하면, 파이썬은 이를 새로운 **지역 변수**로 인식합니다. 전역 변수의 값을 직접 수정하려는 의도였다면 반드시 `global` 키워드를 사용해야 합니다.
          ```python
          count = 10 # 전역 변수
          def my_func():
              # global count  # 이 줄이 없다면 아래 count는 새로운 지역 변수가 됨
              count = 20      # 지역 변수 count에 20을 할당
          my_func()
          print(count) # 결과: 10 (전역 변수는 바뀌지 않음)
          ```
    - **오개념 2: `global` 키워드는 언제나 좋은 해결책이다?**
        - **분석**: `global` 키워드를 남용하면 코드의 흐름을 추적하기 어려워집니다. 함수가 외부의 상태에 직접 의존하게 되어 예측 불가능한 부작용(Side Effect)을 일으킬 수 있고, 이는 디버깅을 어렵게 만듭니다. 좋은 함수는 가능한 한 독립적으로 작동해야 하며, 필요한 값은 매개변수로 받고 결과는 `return`으로 반환하는 것이 바람직합니다.

---

## ❓ 연습 문제 및 해설

### 📝 문제

**1. [파이썬에서 함수를 정의하는 키워드는 무엇인가?](#prob-1)**
   > ① def
   > ② func
   > ③ define
   > ④ define_function

<br>

**2. [다음 중 파이썬에서 함수의 매개변수에 *args와 **kwargs를 사용하는 목적은 무엇인가?](#prob-2)**
   > ① 튜플 형태의 매개변수와 딕셔너리 형태의 매개변수를 받기 위함
   > ② 리스트 형태의 매개변수와 세트 형태의 매개변수를 받기 위함
   > ③ 함수의 인자 개수가 정해져 있지 않을 때, 유연하게 인자를 받기 위함
   > ④ 함수의 반환값을 여러 개로 만들기 위함

<br>

**3. [람다(lambda) 함수에 대한 설명으로 가장 올바른 것은?](#prob-3)**
   > ① 이름이 있는 함수이다.
   > ② 여러 줄의 코드를 작성할 수 있다.
   > ③ 단일 표현식으로 이루어진 익명 함수이다.
   > ④ 인수를 여러 개 받을 수 없다.

---

### 🔑 정답

1. ①
2. ③
3. ③

---

### 🧐 해설

<a id="prob-1"></a>
**1. 파이썬에서 함수를 정의하는 키워드는 무엇인가?**
> **정답: ① `def`**
> **해설**: 파이썬에서는 'define'의 약자인 `def` 키워드를 사용하여 새로운 함수를 정의합니다.

<a id="prob-2"></a>
**2. 다음 중 파이썬에서 `*args`와 `**kwargs`를 사용하는 주된 이유는 무엇인가?**
> **정답: ③ 정해지지 않은 개수의 인수를 유연하게 처리하기 위해서**
> **해설**: `*args`는 정해지지 않은 개수의 위치 인수(positional arguments)를 튜플(tuple)로 묶어서 받습니다. `**kwargs`는 정해지지 않은 개수의 키워드 인수(keyword arguments)를 딕셔너리(dictionary)로 묶어서 받습니다. 이를 통해 함수가 다양한 개수의 인수를 유연하게 처리할 수 있습니다.

<a id="prob-3"></a>
**3. 람다(lambda) 함수에 대한 설명으로 가장 올바른 것은?**
> **정답: ③ 단일 표현식으로 이루어진 익명 함수이다.**
> **해설**: 람다 함수는 이름이 없는 **익명(anonymous)** 함수이며, `lambda 인자: 표현식` 형태로 단 하나의 표현식만으로 구성됩니다. 여러 줄의 코드를 작성할 수 없지만, 간단한 기능을 다른 함수의 인수로 전달할 때 코드를 간결하게 만들어 줍니다.

---

## ✅ O/X 확인문제(연습문항 개수의 2배)

**1.** 함수 정의 시 `def my_func(a=1, b):` 와 같이 기본값 매개변수 뒤에 일반 매개변수를 선언할 수 있다. **(O / X)**
**2.** 함수 내에서 `global` 키워드 없이 전역 변수와 동일한 이름의 변수에 값을 할당하면, 전역 변수의 값이 변경된다. **(O / X)**
**3.** 람다(lambda) 함수는 여러 줄의 복잡한 로직을 처리하기 위해 사용된다. **(O / X)**
**4.** 함수 호출 시 `my_func(name="홍길동", 25)` 와 같이 키워드 인수 뒤에 위치 인수를 사용할 수 있다. **(O / X)**
**5.** 함수 내에서 선언된 지역 변수는 함수 실행이 종료되면 사라진다. **(O / X)**
**6.** `*args`는 여러 개의 키워드 인수를 딕셔너리로 받기 위해 사용된다. **(O / X)**


> <a id="ox-1"></a>
> **1. 정답**: X
> **해설**: 파이썬 함수 정의 시, 기본값이 없는 일반 매개변수가 기본값이 있는 매개변수보다 항상 먼저 와야 합니다. 올바른 순서는 `def my_func(b, a=1):` 입니다.

> <a id="ox-2"></a>
> **2. 정답**: X
> **해설**: 함수 내에서 전역 변수와 같은 이름의 변수에 값을 할당하면, 파이썬은 이를 새로운 **지역 변수**로 간주합니다. 전역 변수의 값은 변경되지 않습니다. 전역 변수를 수정하려면 `global` 키워드를 명시해야 합니다.

> <a id="ox-3"></a>
> **3. 정답**: X
> **해설**: 람다 함수는 단일 표현식으로 구성된 한 줄짜리 익명 함수로, 복잡한 로직이 아닌 간단한 기능을 구현할 때 주로 사용됩니다.

> <a id="ox-4"></a>
> **4. 정답**: X
> **해설**: 함수 호출 시에는 위치 인수가 키워드 인수보다 항상 먼저 와야 합니다. `my_func(25, name="홍길동")` 과 같이 사용해야 합니다.

> <a id="ox-5"></a>
> **5. 정답**: O
> **해설**: 지역 변수(Local Variable)는 해당 함수가 호출될 때 생성되고, 함수 실행이 끝나면 메모리에서 사라지는 유효 범위(scope)를 가집니다.

> <a id="ox-6"></a>
> **6. 정답**: X
> **해설**: `*args`는 여러 개의 **위치 인수**를 **튜플**로 받습니다. 여러 개의 **키워드 인수**를 **딕셔너리**로 받는 것은 `**kwargs`입니다.

---

## 📖 심화 학습 예시 답안

#### 1. 재귀 함수(Recursive Function)를 이용한 팩토리얼 계산

재귀 함수는 함수 내부에서 자기 자신을 다시 호출하는 함수를 말합니다. 이는 복잡한 문제를 더 작고 동일한 구조의 문제로 나누어 해결할 때 유용합니다. 팩토리얼(`n!`) 계산은 재귀의 대표적인 예시입니다.

1.  **재귀 함수의 구성 요소**:
    -   **종료 조건 (Base Case)**: 재귀 호출이 멈추는 조건입니다. 이 조건이 없으면 함수가 무한히 자신을 호출하여 `RecursionError`가 발생합니다. 팩토리얼에서는 `n`이 1 이하일 때 1을 반환하는 것이 종료 조건입니다.
    -   **재귀 호출 (Recursive Step)**: 문제를 더 작은 단위로 쪼개어 자기 자신을 호출하는 부분입니다. 팩토리얼에서는 `n * factorial(n-1)` 부분이 해당됩니다.

```python
def factorial(n):
    # 종료 조건: n이 1 이하이면 1을 반환
    if n <= 1:
        return 1
    # 재귀 호출: n과 n-1의 팩토리얼 결과를 곱함
    else:
        return n * factorial(n - 1)

print(factorial(5)) # 결과: 120 (5 * 4 * 3 * 2 * 1)
```

#### 2. 함수 인수 전달 방식 비교: 위치, 키워드, 기본값

파이썬은 다양한 인수 전달 방식을 지원하여 함수의 유연성을 높입니다.

| 구분 | 위치 인수 (Positional) | 키워드 인수 (Keyword) | 기본값 매개변수 (Default) | 설명 |
| :--- | :--- | :--- | :--- | :--- |
| **정의** | `def func(a, b):` | `def func(a, b):` | `def func(a, b=10):` | 함수를 정의하고 호출하는 방식의 차이 |
| **호출 예시** | `func(1, 2)` | `func(b=2, a=1)` | `func(1)` 또는 `func(1, 20)` | 호출 시 값을 전달하는 방법 |
| **특징** | 인수의 **순서**가 중요하며, 매개변수 순서와 일치해야 합니다. | `매개변수명=값` 형태로 전달하여 **순서에 상관없이** 인수를 지정할 수 있습니다. | 함수 호출 시 인수가 전달되지 않으면 **미리 지정된 기본값**을 사용합니다. | 각 방식의 핵심적인 동작 원리 |
| **장점** | 가장 기본적이고 직관적입니다. | 매개변수의 의미를 명확히 하여 코드 가독성을 높입니다. | 필수가 아닌 선택적 매개변수를 만들 때 유용하며, 호출을 간결하게 합니다. | 각 방식이 제공하는 이점 |
| **주의사항** | 인수의 순서를 잘못 전달하면 의도치 않은 결과가 발생할 수 있습니다. | 매개변수 이름을 정확히 알아야 합니다. | 기본값으로 **리스트나 딕셔너리 같은 변경 가능한(mutable) 객체**를 사용하면 예기치 않은 부작용이 발생할 수 있어 주의해야 합니다. |


#### 3. 클로저(Closure)와 데코레이터(Decorator)의 기초

함수는 일급 객체(First-class citizen)이므로 다른 함수의 인수로 전달되거나, 함수 내에서 새로운 함수를 정의하고 반환할 수 있습니다. 이는 클로저와 데코레이터 같은 고급 패턴의 기반이 됩니다.

- **클로저 (Closure)**: 함수가 종료된 후에도 자신의 **지역 변수를 기억하고 접근할 수 있는** 함수입니다. 외부 함수의 변수를 참조하는 내부 함수가 반환될 때 만들어집니다.
  ```python
  def outer_func(x):
      # x는 outer_func의 지역 변수이지만, inner_func에 의해 '기억'됨
      def inner_func(y):
          return x + y
      return inner_func # 내부 함수를 반환

  add_5 = outer_func(5) # add_5는 x=5를 기억하는 클로저가 됨
  print(add_5(10))      # 결과: 15
  ```
- **데코레이터 (Decorator)**: 기존 함수의 코드를 수정하지 않고도 **새로운 기능을 추가**할 수 있게 해주는 디자인 패턴입니다. `@` 기호를 사용하여 간편하게 적용할 수 있습니다.
  ```python
  def simple_decorator(func):
      def wrapper():
          print("--- 함수 실행 전 ---")
          func() # 원본 함수 실행
          print("--- 함수 실행 후 ---")
      return wrapper

  @simple_decorator
  def say_hello():
      print("안녕하세요!")

  say_hello() # 데코레이터가 적용된 함수 호출
  ```

---

## 🌐 최신 동향 및 추가 정보

### 1. 타입 힌트(Type Hints)를 이용한 함수 명세 (Python 3.5+)
- **개념**: 함수의 매개변수와 반환값이 어떤 타입을 가져야 하는지 명시하는 기능입니다. 코드 실행에 직접적인 영향을 주지는 않지만, 코드의 가독성을 높이고 개발 도구(IDE)나 정적 분석기가 잠재적인 타입 오류를 미리 찾아내는 데 큰 도움을 줍니다.
- **사용법**:
  ```python
  # name은 str, age는 int 타입이며, 반환값은 str 타입임을 명시
  def greeting(name: str, age: int) -> str:
      return f"안녕하세요, {name}님! {age}살이시군요."
  ```
- **중요성**: 협업 환경이나 대규모 프로젝트에서 함수의 의도를 명확히 전달하고, 유지보수성을 향상시키는 중요한 도구로 자리 잡고 있습니다.

### 2. 위치 전용 인수와 키워드 전용 인수 (Python 3.8+)
- **개념**: Python 3.8부터 함수 정의 시 `/`와 `*`를 사용하여 특정 인수를 위치로만 또는 키워드로만 전달하도록 강제할 수 있습니다.
- **사용법**:
  ```python
  def my_func(pos_only, /, standard, *, kw_only):
      # pos_only: 반드시 위치 인수로만 전달해야 함
      # standard: 위치 또는 키워드 인수로 전달 가능
      # kw_only: 반드시 키워드 인수로만 전달해야 함
      print(pos_only, standard, kw_only)

  my_func(1, 2, kw_only=3)       # 올바른 호출
  my_func(1, standard=2, kw_only=3) # 올바른 호출
  # my_func(pos_only=1, ...) -> TypeError 발생
  # my_func(1, 2, 3) -> TypeError 발생
  ```
- **장점**: 라이브러리나 프레임워크 설계 시, 함수의 인수 전달 방식을 명확히 제어하여 오용을 방지하고 API의 안정성을 높일 수 있습니다.

---

## 📚 핵심 용어집 (Glossary)

- **일급 객체 (First-class Citizen)**: 변수에 할당할 수 있고, 다른 함수의 인수로 전달할 수 있으며, 함수의 결과로 반환될 수 있는 객체를 의미합니다. 파이썬에서 함수는 일급 객체입니다.
- **부작용 (Side Effect)**: 함수가 반환값 외에 외부 상태(예: 전역 변수, 파일, 화면 출력)를 변경하는 것을 의미합니다. 부작용이 많은 함수는 예측이 어렵고 테스트하기 힘들어, 일반적으로 부작용을 최소화하는 것이 좋은 설계로 간주됩니다.
- **재귀 함수 (Recursive Function)**: 함수 내부에서 자기 자신을 다시 호출하는 방식으로 동작하는 함수입니다. 반드시 재귀를 멈추는 종료 조건(base case)이 있어야 합니다.
- **익명 함수 (Anonymous Function)**: 이름이 없는 함수를 의미하며, 파이썬에서는 `lambda` 키워드를 사용하여 생성합니다.
- **클로저 (Closure)**: 자신을 둘러싼 외부 함수의 환경(지역 변수 등)을 기억하고, 외부 함수가 종료된 후에도 해당 변수에 접근할 수 있는 함수입니다.
- **데코레이터 (Decorator)**: 다른 함수를 인자로 받아, 기존 함수의 코드를 수정하지 않고 새로운 기능을 추가하거나 수정하여 새로운 함수를 반환하는 함수 또는 패턴입니다. `@` 구문을 사용하여 간결하게 적용할 수 있습니다.

---

## 🤖 AI 학습 파트너를 위한 추가 자료

### 1. 재귀 함수와 반복문의 성능 비교 질문
> **프롬프트 예시**: "피보나치 수열을 계산하는 함수를 '재귀 함수'를 사용하는 방법과 'for 반복문'을 사용하는 방법 두 가지로 각각 작성해주세요. 그리고 n=30일 때 두 방법의 실행 시간을 비교하고, 왜 이런 성능 차이가 발생하는지 설명해주세요."

### 2. 클로저의 동작 원리 심화 질문
> **프롬프트 예시**: "파이썬 클로저가 외부 함수의 변수를 어떻게 '기억'할 수 있는지, 내부적으로 어떤 원리로 동작하는지 설명해주세요. 그리고 클로저를 사용하면 어떤 실용적인 이점이 있는지 구체적인 예시를 들어 설명해주세요. (예: 상태 유지, 콜백 함수 등)"

---

## 📚 참고 자료 (References)

- 파이썬 공식 튜토리얼 - 함수 정의하기
- Real Python - Python Decorators 101